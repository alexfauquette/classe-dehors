{"ast":null,"code":"/*\n * Copyright (c) 2016-2020 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar IdentifierIssuer = require('./IdentifierIssuer');\n\nvar MessageDigest = require('./MessageDigest');\n\nvar Permuter = require('./Permuter');\n\nvar NQuads = require('./NQuads');\n\nmodule.exports = /*#__PURE__*/function () {\n  function URDNA2015() {\n    _classCallCheck(this, URDNA2015);\n\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    this.hashAlgorithm = 'sha256';\n    this.quads = null;\n  } // 4.4) Normalization Algorithm\n\n\n  _createClass(URDNA2015, [{\n    key: \"main\",\n    value: function () {\n      var _main = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataset) {\n        var _iterator, _step, quad, hashToBlankNodes, nonNormalized, i, _iterator2, _step2, _id2, hashes, nonUnique, _iterator3, _step3, hash, _idList, _id3, _i, _nonUnique, idList, hashPathList, _iterator4, _step4, _id, issuer, _result, _i2, _hashPathList, result, oldIds, _iterator5, _step5, id, normalized, _iterator6, _step6, _quad, q;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.quads = dataset; // 1) Create the normalization state.\n                // 2) For every quad in input dataset:\n\n                _iterator = _createForOfIteratorHelper(dataset);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    quad = _step.value;\n\n                    // 2.1) For each blank node that occurs in the quad, add a reference\n                    // to the quad using the blank node identifier in the blank node to\n                    // quads map, creating a new entry if necessary.\n                    this._addBlankNodeQuadInfo({\n                      quad: quad,\n                      component: quad.subject\n                    });\n\n                    this._addBlankNodeQuadInfo({\n                      quad: quad,\n                      component: quad.object\n                    });\n\n                    this._addBlankNodeQuadInfo({\n                      quad: quad,\n                      component: quad.graph\n                    });\n                  } // 3) Create a list of non-normalized blank node identifiers\n                  // non-normalized identifiers and populate it using the keys from the\n                  // blank node to quads map.\n                  // Note: We use a map here and it was generated during step 2.\n                  // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n                  // is permitted because there was a typo in the hash first degree quads\n                  // algorithm in the URDNA2015 spec that was implemented widely making it\n                  // such that it could not be fixed; the result was that the loop only\n                  // needs to be run once and the first degree quad hashes will never change.\n                  // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n                  // for all non-normalized blank nodes.\n                  // 5.3) For each blank node identifier identifier in non-normalized\n                  // identifiers:\n\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                hashToBlankNodes = new Map();\n                nonNormalized = _toConsumableArray(this.blankNodeInfo.keys());\n                i = 0;\n                _iterator2 = _createForOfIteratorHelper(nonNormalized);\n                _context.prev = 7;\n\n                _iterator2.s();\n\n              case 9:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 18;\n                  break;\n                }\n\n                _id2 = _step2.value;\n\n                if (!(++i % 100 === 0)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.next = 14;\n                return this._yield();\n\n              case 14:\n                _context.next = 16;\n                return this._hashAndTrackBlankNode({\n                  id: _id2,\n                  hashToBlankNodes: hashToBlankNodes\n                });\n\n              case 16:\n                _context.next = 9;\n                break;\n\n              case 18:\n                _context.next = 23;\n                break;\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](7);\n\n                _iterator2.e(_context.t0);\n\n              case 23:\n                _context.prev = 23;\n\n                _iterator2.f();\n\n                return _context.finish(23);\n\n              case 26:\n                // 5.4) For each hash to identifier list mapping in hash to blank\n                // nodes map, lexicographically-sorted by hash:\n                hashes = _toConsumableArray(hashToBlankNodes.keys()).sort(); // optimize away second sort, gather non-unique hashes in order as we go\n\n                nonUnique = [];\n                _iterator3 = _createForOfIteratorHelper(hashes);\n                _context.prev = 29;\n\n                _iterator3.s();\n\n              case 31:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context.next = 41;\n                  break;\n                }\n\n                hash = _step3.value;\n                // 5.4.1) If the length of identifier list is greater than 1,\n                // continue to the next mapping.\n                _idList = hashToBlankNodes.get(hash);\n\n                if (!(_idList.length > 1)) {\n                  _context.next = 37;\n                  break;\n                }\n\n                nonUnique.push(_idList);\n                return _context.abrupt(\"continue\", 39);\n\n              case 37:\n                // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n                // issuer and the single blank node identifier in identifier\n                // list, identifier, to issue a canonical replacement identifier\n                // for identifier.\n                _id3 = _idList[0];\n                this.canonicalIssuer.getId(_id3); // Note: These steps are skipped, optimized away since the loop\n                // only needs to be run once.\n                // 5.4.3) Remove identifier from non-normalized identifiers.\n                // 5.4.4) Remove hash from the hash to blank nodes map.\n                // 5.4.5) Set simple to true.\n\n              case 39:\n                _context.next = 31;\n                break;\n\n              case 41:\n                _context.next = 46;\n                break;\n\n              case 43:\n                _context.prev = 43;\n                _context.t1 = _context[\"catch\"](29);\n\n                _iterator3.e(_context.t1);\n\n              case 46:\n                _context.prev = 46;\n\n                _iterator3.f();\n\n                return _context.finish(46);\n\n              case 49:\n                _i = 0, _nonUnique = nonUnique;\n\n              case 50:\n                if (!(_i < _nonUnique.length)) {\n                  _context.next = 81;\n                  break;\n                }\n\n                idList = _nonUnique[_i];\n                // 6.1) Create hash path list where each item will be a result of\n                // running the Hash N-Degree Quads algorithm.\n                hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:\n\n                _iterator4 = _createForOfIteratorHelper(idList);\n                _context.prev = 54;\n\n                _iterator4.s();\n\n              case 56:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context.next = 68;\n                  break;\n                }\n\n                _id = _step4.value;\n\n                if (!this.canonicalIssuer.hasId(_id)) {\n                  _context.next = 60;\n                  break;\n                }\n\n                return _context.abrupt(\"continue\", 66);\n\n              case 60:\n                // 6.2.2) Create temporary issuer, an identifier issuer\n                // initialized with the prefix _:b.\n                issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n                // issuer and identifier, to issue a new temporary blank node\n                // identifier for identifier.\n\n                issuer.getId(_id); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n                // temporary issuer, and append the result to the hash path list.\n\n                _context.next = 64;\n                return this.hashNDegreeQuads(_id, issuer);\n\n              case 64:\n                _result = _context.sent;\n                hashPathList.push(_result);\n\n              case 66:\n                _context.next = 56;\n                break;\n\n              case 68:\n                _context.next = 73;\n                break;\n\n              case 70:\n                _context.prev = 70;\n                _context.t2 = _context[\"catch\"](54);\n\n                _iterator4.e(_context.t2);\n\n              case 73:\n                _context.prev = 73;\n\n                _iterator4.f();\n\n                return _context.finish(73);\n\n              case 76:\n                // 6.3) For each result in the hash path list,\n                // lexicographically-sorted by the hash in result:\n                hashPathList.sort(_stringHashCompare);\n\n                for (_i2 = 0, _hashPathList = hashPathList; _i2 < _hashPathList.length; _i2++) {\n                  result = _hashPathList[_i2];\n                  // 6.3.1) For each blank node identifier, existing identifier,\n                  // that was issued a temporary identifier by identifier issuer\n                  // in result, issue a canonical identifier, in the same order,\n                  // using the Issue Identifier algorithm, passing canonical\n                  // issuer and existing identifier.\n                  oldIds = result.issuer.getOldIds();\n                  _iterator5 = _createForOfIteratorHelper(oldIds);\n\n                  try {\n                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                      id = _step5.value;\n                      this.canonicalIssuer.getId(id);\n                    }\n                  } catch (err) {\n                    _iterator5.e(err);\n                  } finally {\n                    _iterator5.f();\n                  }\n                }\n\n              case 78:\n                _i++;\n                _context.next = 50;\n                break;\n\n              case 81:\n                /* Note: At this point all blank nodes in the set of RDF quads have been\n                assigned canonical identifiers, which have been stored in the canonical\n                issuer. Here each quad is updated by assigning each of its blank nodes\n                its new identifier. */\n                // 7) For each quad, quad, in input dataset:\n                normalized = [];\n                _iterator6 = _createForOfIteratorHelper(this.quads);\n\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    _quad = _step6.value;\n                    // 7.1) Create a copy, quad copy, of quad and replace any existing\n                    // blank node identifiers using the canonical identifiers\n                    // previously issued by canonical issuer.\n                    // Note: We optimize with shallow copies here.\n                    q = _objectSpread({}, _quad);\n                    q.subject = this._useCanonicalId({\n                      component: q.subject\n                    });\n                    q.object = this._useCanonicalId({\n                      component: q.object\n                    });\n                    q.graph = this._useCanonicalId({\n                      component: q.graph\n                    }); // 7.2) Add quad copy to the normalized dataset.\n\n                    normalized.push(NQuads.serializeQuad(q));\n                  } // sort normalized output\n\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n\n                normalized.sort(); // 8) Return the normalized dataset.\n\n                return _context.abrupt(\"return\", normalized.join(''));\n\n              case 86:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 20, 23, 26], [29, 43, 46, 49], [54, 70, 73, 76]]);\n      }));\n\n      function main(_x) {\n        return _main.apply(this, arguments);\n      }\n\n      return main;\n    }() // 4.6) Hash First Degree Quads\n\n  }, {\n    key: \"hashFirstDegreeQuads\",\n    value: function () {\n      var _hashFirstDegreeQuads = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id) {\n        var nquads, info, quads, _iterator7, _step7, quad, copy, md, _i3, _nquads, nquad;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // 1) Initialize nquads to an empty list. It will be used to store quads in\n                // N-Quads format.\n                nquads = []; // 2) Get the list of quads `quads` associated with the reference blank node\n                // identifier in the blank node to quads map.\n\n                info = this.blankNodeInfo.get(id);\n                quads = info.quads; // 3) For each quad `quad` in `quads`:\n\n                _iterator7 = _createForOfIteratorHelper(quads);\n\n                try {\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    quad = _step7.value;\n                    // 3.1) Serialize the quad in N-Quads format with the following special\n                    // rule:\n                    // 3.1.1) If any component in quad is an blank node, then serialize it\n                    // using a special identifier as follows:\n                    copy = {\n                      subject: null,\n                      predicate: quad.predicate,\n                      object: null,\n                      graph: null\n                    }; // 3.1.2) If the blank node's existing blank node identifier matches\n                    // the reference blank node identifier then use the blank node\n                    // identifier _:a, otherwise, use the blank node identifier _:z.\n\n                    copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, 'subject');\n                    copy.object = this.modifyFirstDegreeComponent(id, quad.object, 'object');\n                    copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, 'graph');\n                    nquads.push(NQuads.serializeQuad(copy));\n                  } // 4) Sort nquads in lexicographical order.\n\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n\n                nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads\n                // through the hash algorithm.\n\n                md = new MessageDigest(this.hashAlgorithm);\n\n                for (_i3 = 0, _nquads = nquads; _i3 < _nquads.length; _i3++) {\n                  nquad = _nquads[_i3];\n                  md.update(nquad);\n                }\n\n                _context2.next = 10;\n                return md.digest();\n\n              case 10:\n                info.hash = _context2.sent;\n                return _context2.abrupt(\"return\", info.hash);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function hashFirstDegreeQuads(_x2) {\n        return _hashFirstDegreeQuads.apply(this, arguments);\n      }\n\n      return hashFirstDegreeQuads;\n    }() // 4.7) Hash Related Blank Node\n\n  }, {\n    key: \"hashRelatedBlankNode\",\n    value: function () {\n      var _hashRelatedBlankNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(related, quad, issuer, position) {\n        var id, md;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // 1) Set the identifier to use for related, preferring first the canonical\n                // identifier for related if issued, second the identifier issued by issuer\n                // if issued, and last, if necessary, the result of the Hash First Degree\n                // Quads algorithm, passing related.\n                if (this.canonicalIssuer.hasId(related)) {\n                  id = this.canonicalIssuer.getId(related);\n                } else if (issuer.hasId(related)) {\n                  id = issuer.getId(related);\n                } else {\n                  id = this.blankNodeInfo.get(related).hash;\n                } // 2) Initialize a string input to the value of position.\n                // Note: We use a hash object instead.\n\n\n                md = new MessageDigest(this.hashAlgorithm);\n                md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,\n                // and > to input.\n\n                if (position !== 'g') {\n                  md.update(this.getRelatedPredicate(quad));\n                } // 4) Append identifier to input.\n\n\n                md.update(id); // 5) Return the hash that results from passing input through the hash\n                // algorithm.\n\n                return _context3.abrupt(\"return\", md.digest());\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function hashRelatedBlankNode(_x3, _x4, _x5, _x6) {\n        return _hashRelatedBlankNode.apply(this, arguments);\n      }\n\n      return hashRelatedBlankNode;\n    }() // 4.8) Hash N-Degree Quads\n\n  }, {\n    key: \"hashNDegreeQuads\",\n    value: function () {\n      var _hashNDegreeQuads = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id, issuer) {\n        var md, hashToRelated, hashes, _iterator8, _step8, hash, chosenPath, chosenIssuer, permuter, i, permutation, issuerCopy, path, recursionList, nextPermutation, _iterator9, _step9, _related, _i4, _recursionList, related, result;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // 1) Create a hash to related blank nodes map for storing hashes that\n                // identify related blank nodes.\n                // Note: 2) and 3) handled within `createHashToRelated`\n                md = new MessageDigest(this.hashAlgorithm);\n                _context4.next = 3;\n                return this.createHashToRelated(id, issuer);\n\n              case 3:\n                hashToRelated = _context4.sent;\n                // 4) Create an empty string, data to hash.\n                // Note: We created a hash object `md` above instead.\n                // 5) For each related hash to blank node list mapping in hash to related\n                // blank nodes map, sorted lexicographically by related hash:\n                hashes = _toConsumableArray(hashToRelated.keys()).sort();\n                _iterator8 = _createForOfIteratorHelper(hashes);\n                _context4.prev = 6;\n\n                _iterator8.s();\n\n              case 8:\n                if ((_step8 = _iterator8.n()).done) {\n                  _context4.next = 69;\n                  break;\n                }\n\n                hash = _step8.value;\n                // 5.1) Append the related hash to the data to hash.\n                md.update(hash); // 5.2) Create a string chosen path.\n\n                chosenPath = ''; // 5.3) Create an unset chosen issuer variable.\n\n                chosenIssuer = void 0; // 5.4) For each permutation of blank node list:\n\n                permuter = new Permuter(hashToRelated.get(hash));\n                i = 0;\n\n              case 15:\n                if (!permuter.hasNext()) {\n                  _context4.next = 65;\n                  break;\n                }\n\n                permutation = permuter.next(); // Note: batch permutations 3 at a time\n\n                if (!(++i % 3 === 0)) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                _context4.next = 20;\n                return this._yield();\n\n              case 20:\n                // 5.4.1) Create a copy of issuer, issuer copy.\n                issuerCopy = issuer.clone(); // 5.4.2) Create a string path.\n\n                path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers\n                // that must be recursively processed by this algorithm.\n\n                recursionList = []; // 5.4.4) For each related in permutation:\n\n                nextPermutation = false;\n                _iterator9 = _createForOfIteratorHelper(permutation);\n                _context4.prev = 25;\n\n                _iterator9.s();\n\n              case 27:\n                if ((_step9 = _iterator9.n()).done) {\n                  _context4.next = 35;\n                  break;\n                }\n\n                _related = _step9.value;\n\n                // 5.4.4.1) If a canonical identifier has been issued for\n                // related, append it to path.\n                if (this.canonicalIssuer.hasId(_related)) {\n                  path += this.canonicalIssuer.getId(_related);\n                } else {\n                  // 5.4.4.2) Otherwise:\n                  // 5.4.4.2.1) If issuer copy has not issued an identifier for\n                  // related, append related to recursion list.\n                  if (!issuerCopy.hasId(_related)) {\n                    recursionList.push(_related);\n                  } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n                  // issuer copy and related and append the result to path.\n\n\n                  path += issuerCopy.getId(_related);\n                } // 5.4.4.3) If chosen path is not empty and the length of path\n                // is greater than or equal to the length of chosen path and\n                // path is lexicographically greater than chosen path, then\n                // skip to the next permutation.\n                // Note: Comparing path length to chosen path length can be optimized\n                // away; only compare lexicographically.\n\n\n                if (!(chosenPath.length !== 0 && path > chosenPath)) {\n                  _context4.next = 33;\n                  break;\n                }\n\n                nextPermutation = true;\n                return _context4.abrupt(\"break\", 35);\n\n              case 33:\n                _context4.next = 27;\n                break;\n\n              case 35:\n                _context4.next = 40;\n                break;\n\n              case 37:\n                _context4.prev = 37;\n                _context4.t0 = _context4[\"catch\"](25);\n\n                _iterator9.e(_context4.t0);\n\n              case 40:\n                _context4.prev = 40;\n\n                _iterator9.f();\n\n                return _context4.finish(40);\n\n              case 43:\n                if (!nextPermutation) {\n                  _context4.next = 45;\n                  break;\n                }\n\n                return _context4.abrupt(\"continue\", 15);\n\n              case 45:\n                _i4 = 0, _recursionList = recursionList;\n\n              case 46:\n                if (!(_i4 < _recursionList.length)) {\n                  _context4.next = 60;\n                  break;\n                }\n\n                related = _recursionList[_i4];\n                _context4.next = 50;\n                return this.hashNDegreeQuads(related, issuerCopy);\n\n              case 50:\n                result = _context4.sent;\n                // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n                // copy and related and append the result to path.\n                path += issuerCopy.getId(related); // 5.4.5.3) Append <, the hash in result, and > to path.\n\n                path += \"<\".concat(result.hash, \">\"); // 5.4.5.4) Set issuer copy to the identifier issuer in\n                // result.\n\n                issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of path\n                // is greater than or equal to the length of chosen path and\n                // path is lexicographically greater than chosen path, then\n                // skip to the next permutation.\n                // Note: Comparing path length to chosen path length can be optimized\n                // away; only compare lexicographically.\n\n                if (!(chosenPath.length !== 0 && path > chosenPath)) {\n                  _context4.next = 57;\n                  break;\n                }\n\n                nextPermutation = true;\n                return _context4.abrupt(\"break\", 60);\n\n              case 57:\n                _i4++;\n                _context4.next = 46;\n                break;\n\n              case 60:\n                if (!nextPermutation) {\n                  _context4.next = 62;\n                  break;\n                }\n\n                return _context4.abrupt(\"continue\", 15);\n\n              case 62:\n                // 5.4.6) If chosen path is empty or path is lexicographically\n                // less than chosen path, set chosen path to path and chosen\n                // issuer to issuer copy.\n                if (chosenPath.length === 0 || path < chosenPath) {\n                  chosenPath = path;\n                  chosenIssuer = issuerCopy;\n                }\n\n                _context4.next = 15;\n                break;\n\n              case 65:\n                // 5.5) Append chosen path to data to hash.\n                md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.\n\n                issuer = chosenIssuer;\n\n              case 67:\n                _context4.next = 8;\n                break;\n\n              case 69:\n                _context4.next = 74;\n                break;\n\n              case 71:\n                _context4.prev = 71;\n                _context4.t1 = _context4[\"catch\"](6);\n\n                _iterator8.e(_context4.t1);\n\n              case 74:\n                _context4.prev = 74;\n\n                _iterator8.f();\n\n                return _context4.finish(74);\n\n              case 77:\n                _context4.next = 79;\n                return md.digest();\n\n              case 79:\n                _context4.t2 = _context4.sent;\n                _context4.t3 = issuer;\n                return _context4.abrupt(\"return\", {\n                  hash: _context4.t2,\n                  issuer: _context4.t3\n                });\n\n              case 82:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[6, 71, 74, 77], [25, 37, 40, 43]]);\n      }));\n\n      function hashNDegreeQuads(_x7, _x8) {\n        return _hashNDegreeQuads.apply(this, arguments);\n      }\n\n      return hashNDegreeQuads;\n    }() // helper for modifying component during Hash First Degree Quads\n\n  }, {\n    key: \"modifyFirstDegreeComponent\",\n    value: function modifyFirstDegreeComponent(id, component) {\n      if (component.termType !== 'BlankNode') {\n        return component;\n      }\n      /* Note: A mistake in the URDNA2015 spec that made its way into\n      implementations (and therefore must stay to avoid interop breakage)\n      resulted in an assigned canonical ID, if available for\n      `component.value`, not being used in place of `_:a`/`_:z`, so\n      we don't use it here. */\n\n\n      return {\n        termType: 'BlankNode',\n        value: component.value === id ? '_:a' : '_:z'\n      };\n    } // helper for getting a related predicate\n\n  }, {\n    key: \"getRelatedPredicate\",\n    value: function getRelatedPredicate(quad) {\n      return \"<\".concat(quad.predicate.value, \">\");\n    } // helper for creating hash to related blank nodes map\n\n  }, {\n    key: \"createHashToRelated\",\n    value: function () {\n      var _createHashToRelated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(id, issuer) {\n        var hashToRelated, quads, i, _iterator10, _step10, quad;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // 1) Create a hash to related blank nodes map for storing hashes that\n                // identify related blank nodes.\n                hashToRelated = new Map(); // 2) Get a reference, quads, to the list of quads in the blank node to\n                // quads map for the key identifier.\n\n                quads = this.blankNodeInfo.get(id).quads; // 3) For each quad in quads:\n\n                i = 0;\n                _iterator10 = _createForOfIteratorHelper(quads);\n                _context5.prev = 4;\n\n                _iterator10.s();\n\n              case 6:\n                if ((_step10 = _iterator10.n()).done) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                quad = _step10.value;\n\n                if (!(++i % 100 === 0)) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                _context5.next = 11;\n                return this._yield();\n\n              case 11:\n                _context5.next = 13;\n                return Promise.all([this._addRelatedBlankNodeHash({\n                  quad: quad,\n                  component: quad.subject,\n                  position: 's',\n                  id: id,\n                  issuer: issuer,\n                  hashToRelated: hashToRelated\n                }), this._addRelatedBlankNodeHash({\n                  quad: quad,\n                  component: quad.object,\n                  position: 'o',\n                  id: id,\n                  issuer: issuer,\n                  hashToRelated: hashToRelated\n                }), this._addRelatedBlankNodeHash({\n                  quad: quad,\n                  component: quad.graph,\n                  position: 'g',\n                  id: id,\n                  issuer: issuer,\n                  hashToRelated: hashToRelated\n                })]);\n\n              case 13:\n                _context5.next = 6;\n                break;\n\n              case 15:\n                _context5.next = 20;\n                break;\n\n              case 17:\n                _context5.prev = 17;\n                _context5.t0 = _context5[\"catch\"](4);\n\n                _iterator10.e(_context5.t0);\n\n              case 20:\n                _context5.prev = 20;\n\n                _iterator10.f();\n\n                return _context5.finish(20);\n\n              case 23:\n                return _context5.abrupt(\"return\", hashToRelated);\n\n              case 24:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[4, 17, 20, 23]]);\n      }));\n\n      function createHashToRelated(_x9, _x10) {\n        return _createHashToRelated.apply(this, arguments);\n      }\n\n      return createHashToRelated;\n    }()\n  }, {\n    key: \"_hashAndTrackBlankNode\",\n    value: function () {\n      var _hashAndTrackBlankNode2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref) {\n        var id, hashToBlankNodes, hash, idList;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                id = _ref.id, hashToBlankNodes = _ref.hashToBlankNodes;\n                _context6.next = 3;\n                return this.hashFirstDegreeQuads(id);\n\n              case 3:\n                hash = _context6.sent;\n                // 5.3.2) Add hash and identifier to hash to blank nodes map,\n                // creating a new entry if necessary.\n                idList = hashToBlankNodes.get(hash);\n\n                if (!idList) {\n                  hashToBlankNodes.set(hash, [id]);\n                } else {\n                  idList.push(id);\n                }\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _hashAndTrackBlankNode(_x11) {\n        return _hashAndTrackBlankNode2.apply(this, arguments);\n      }\n\n      return _hashAndTrackBlankNode;\n    }()\n  }, {\n    key: \"_addBlankNodeQuadInfo\",\n    value: function _addBlankNodeQuadInfo(_ref2) {\n      var quad = _ref2.quad,\n          component = _ref2.component;\n\n      if (component.termType !== 'BlankNode') {\n        return;\n      }\n\n      var id = component.value;\n      var info = this.blankNodeInfo.get(id);\n\n      if (info) {\n        info.quads.add(quad);\n      } else {\n        this.blankNodeInfo.set(id, {\n          quads: new Set([quad]),\n          hash: null\n        });\n      }\n    }\n  }, {\n    key: \"_addRelatedBlankNodeHash\",\n    value: function () {\n      var _addRelatedBlankNodeHash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref3) {\n        var quad, component, position, id, issuer, hashToRelated, related, hash, entries;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                quad = _ref3.quad, component = _ref3.component, position = _ref3.position, id = _ref3.id, issuer = _ref3.issuer, hashToRelated = _ref3.hashToRelated;\n\n                if (component.termType === 'BlankNode' && component.value !== id) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 3:\n                // 3.1.1) Set hash to the result of the Hash Related Blank Node\n                // algorithm, passing the blank node identifier for component as\n                // related, quad, path identifier issuer as issuer, and position as\n                // either s, o, or g based on whether component is a subject, object,\n                // graph name, respectively.\n                related = component.value;\n                _context7.next = 6;\n                return this.hashRelatedBlankNode(related, quad, issuer, position);\n\n              case 6:\n                hash = _context7.sent;\n                // 3.1.2) Add a mapping of hash to the blank node identifier for\n                // component to hash to related blank nodes map, adding an entry as\n                // necessary.\n                entries = hashToRelated.get(hash);\n\n                if (entries) {\n                  entries.push(related);\n                } else {\n                  hashToRelated.set(hash, [related]);\n                }\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _addRelatedBlankNodeHash(_x12) {\n        return _addRelatedBlankNodeHash2.apply(this, arguments);\n      }\n\n      return _addRelatedBlankNodeHash;\n    }()\n  }, {\n    key: \"_useCanonicalId\",\n    value: function _useCanonicalId(_ref4) {\n      var component = _ref4.component;\n\n      if (component.termType === 'BlankNode' && !component.value.startsWith(this.canonicalIssuer.prefix)) {\n        return {\n          termType: 'BlankNode',\n          value: this.canonicalIssuer.getId(component.value)\n        };\n      }\n\n      return component;\n    }\n  }, {\n    key: \"_yield\",\n    value: function () {\n      var _yield2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", new Promise(function (resolve) {\n                  return setImmediate(resolve);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function _yield() {\n        return _yield2.apply(this, arguments);\n      }\n\n      return _yield;\n    }()\n  }]);\n\n  return URDNA2015;\n}();\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}","map":{"version":3,"sources":["/home/alexandre/dev/classe-dehors/frontend/node_modules/rdf-canonize/lib/URDNA2015.js"],"names":["IdentifierIssuer","require","MessageDigest","Permuter","NQuads","module","exports","name","blankNodeInfo","Map","canonicalIssuer","hashAlgorithm","quads","dataset","quad","_addBlankNodeQuadInfo","component","subject","object","graph","hashToBlankNodes","nonNormalized","keys","i","id","_yield","_hashAndTrackBlankNode","hashes","sort","nonUnique","hash","idList","get","length","push","getId","hashPathList","hasId","issuer","hashNDegreeQuads","result","_stringHashCompare","oldIds","getOldIds","normalized","q","_useCanonicalId","serializeQuad","join","nquads","info","copy","predicate","modifyFirstDegreeComponent","md","nquad","update","digest","related","position","getRelatedPredicate","createHashToRelated","hashToRelated","chosenPath","chosenIssuer","permuter","hasNext","permutation","next","issuerCopy","clone","path","recursionList","nextPermutation","termType","value","Promise","all","_addRelatedBlankNodeHash","hashFirstDegreeQuads","set","add","Set","hashRelatedBlankNode","entries","startsWith","prefix","resolve","setImmediate","a","b"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-2020 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst IdentifierIssuer = require('./IdentifierIssuer');\nconst MessageDigest = require('./MessageDigest');\nconst Permuter = require('./Permuter');\nconst NQuads = require('./NQuads');\n\nmodule.exports = class URDNA2015 {\n  constructor() {\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    this.hashAlgorithm = 'sha256';\n    this.quads = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  async main(dataset) {\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the URDNA2015 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    let i = 0;\n    for(const id of nonNormalized) {\n      // Note: batch hashing first degree quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // steps 5.3.1 and 5.3.2:\n      await this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('_:b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = await this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize with shallow copies here.\n      const q = {...quad};\n      q.subject = this._useCanonicalId({component: q.subject});\n      q.object = this._useCanonicalId({component: q.object});\n      q.graph = this._useCanonicalId({component: q.graph});\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(NQuads.serializeQuad(q));\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  async hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      const copy = {\n        subject: null, predicate: quad.predicate, object: null, graph: null\n      };\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      copy.subject = this.modifyFirstDegreeComponent(\n        id, quad.subject, 'subject');\n      copy.object = this.modifyFirstDegreeComponent(\n        id, quad.object, 'object');\n      copy.graph = this.modifyFirstDegreeComponent(\n        id, quad.graph, 'graph');\n      nquads.push(NQuads.serializeQuad(copy));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = new MessageDigest(this.hashAlgorithm);\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = await md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  async hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 2) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = new MessageDigest(this.hashAlgorithm);\n    md.update(position);\n\n    // 3) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  async hashNDegreeQuads(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = new MessageDigest(this.hashAlgorithm);\n    const hashToRelated = await this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      let i = 0;\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n        // Note: batch permutations 3 at a time\n        if(++i % 3 === 0) {\n          await this._yield();\n        }\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = await this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: await md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the URDNA2015 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? '_:a' : '_:z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // Note: batch hashing related blank node quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.1) For each component in quad, if component is the subject, object,\n      // and graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      await Promise.all([\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.subject, position: 's',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.object, position: 'o',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.graph, position: 'g',\n          id, issuer, hashToRelated\n        })\n      ]);\n    }\n\n    return hashToRelated;\n  }\n\n  async _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = await this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  async _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = await this.hashRelatedBlankNode(\n      related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  _useCanonicalId({component}) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n\n  async _yield() {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n"]},"metadata":{},"sourceType":"script"}