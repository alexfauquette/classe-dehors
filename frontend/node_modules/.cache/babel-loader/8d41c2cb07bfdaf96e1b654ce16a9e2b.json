{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('../util'),\n    parseLinkHeader = _require.parseLinkHeader,\n    buildHeaders = _require.buildHeaders;\n\nvar _require2 = require('../constants'),\n    LINK_HEADER_CONTEXT = _require2.LINK_HEADER_CONTEXT;\n\nvar JsonLdError = require('../JsonLdError');\n\nvar RequestQueue = require('../RequestQueue');\n\nvar _require3 = require('../url'),\n    prependBase = _require3.prependBase;\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\n\n\nmodule.exports = function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    strictSSL: true,\n    maxRedirects: -1,\n    headers: {}\n  },\n      secure = _ref.secure,\n      _ref$strictSSL = _ref.strictSSL,\n      strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,\n      _ref$maxRedirects = _ref.maxRedirects,\n      maxRedirects = _ref$maxRedirects === void 0 ? -1 : _ref$maxRedirects,\n      request = _ref.request,\n      _ref$headers = _ref.headers,\n      headers = _ref$headers === void 0 ? {} : _ref$headers;\n\n  headers = buildHeaders(headers); // TODO: use `axios`\n\n  request = request || require('request');\n\n  var http = require('http');\n\n  var queue = new RequestQueue();\n  return queue.wrapLoader(function (url) {\n    return loadDocument(url, []);\n  });\n\n  function loadDocument(_x, _x2) {\n    return _loadDocument.apply(this, arguments);\n  }\n\n  function _loadDocument() {\n    _loadDocument = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, redirects) {\n      var doc, result, alternate, _result, res, body, statusText, linkHeaders, linkedContext;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {\n                _context.next = 2;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {\n                code: 'loading document failed',\n                url: url\n              });\n\n            case 2:\n              if (!(secure && url.indexOf('https') !== 0)) {\n                _context.next = 4;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\\'s scheme is not \"https\".', 'jsonld.InvalidUrl', {\n                code: 'loading document failed',\n                url: url\n              });\n\n            case 4:\n              // TODO: disable cache until HTTP caching implemented\n              doc = null; //cache.get(url);\n\n              if (!(doc !== null)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\", doc);\n\n            case 7:\n              alternate = null;\n              _context.prev = 8;\n              _context.next = 11;\n              return _request(request, {\n                url: url,\n                headers: headers,\n                strictSSL: strictSSL,\n                followRedirect: false\n              });\n\n            case 11:\n              result = _context.sent;\n              _context.next = 17;\n              break;\n\n            case 14:\n              _context.prev = 14;\n              _context.t0 = _context[\"catch\"](8);\n              throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {\n                code: 'loading document failed',\n                url: url,\n                cause: _context.t0\n              });\n\n            case 17:\n              _result = result, res = _result.res, body = _result.body;\n              doc = {\n                contextUrl: null,\n                documentUrl: url,\n                document: body || null\n              }; // handle error\n\n              statusText = http.STATUS_CODES[res.statusCode];\n\n              if (!(res.statusCode >= 400)) {\n                _context.next = 22;\n                break;\n              }\n\n              throw new JsonLdError(\"URL \\\"\".concat(url, \"\\\" could not be dereferenced: \").concat(statusText), 'jsonld.InvalidUrl', {\n                code: 'loading document failed',\n                url: url,\n                httpStatusCode: res.statusCode\n              });\n\n            case 22:\n              if (!(res.headers.link && res.headers['content-type'] !== 'application/ld+json')) {\n                _context.next = 30;\n                break;\n              }\n\n              // only 1 related link header permitted\n              linkHeaders = parseLinkHeader(res.headers.link);\n              linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n\n              if (!Array.isArray(linkedContext)) {\n                _context.next = 27;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {\n                code: 'multiple context link headers',\n                url: url\n              });\n\n            case 27:\n              if (linkedContext) {\n                doc.contextUrl = linkedContext.target;\n              } // \"alternate\" link header is a redirect\n\n\n              alternate = linkHeaders['alternate'];\n\n              if (alternate && alternate.type == 'application/ld+json' && !(res.headers['content-type'] || '').match(/^application\\/(\\w*\\+)?json$/)) {\n                res.headers.location = prependBase(url, alternate.target);\n              }\n\n            case 30:\n              if (!((alternate || res.statusCode >= 300 && res.statusCode < 400) && res.headers.location)) {\n                _context.next = 37;\n                break;\n              }\n\n              if (!(redirects.length === maxRedirects)) {\n                _context.next = 33;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {\n                code: 'loading document failed',\n                url: url,\n                httpStatusCode: res.statusCode,\n                redirects: redirects\n              });\n\n            case 33:\n              if (!(redirects.indexOf(url) !== -1)) {\n                _context.next = 35;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {\n                code: 'recursive context inclusion',\n                url: url,\n                httpStatusCode: res.statusCode,\n                redirects: redirects\n              });\n\n            case 35:\n              redirects.push(url);\n              return _context.abrupt(\"return\", loadDocument(res.headers.location, redirects));\n\n            case 37:\n              // cache for each redirected URL\n              redirects.push(url); // TODO: disable cache until HTTP caching implemented\n\n              /*\n              for(let i = 0; i < redirects.length; ++i) {\n                cache.set(\n                  redirects[i],\n                  {contextUrl: null, documentUrl: redirects[i], document: body});\n              }\n              */\n\n              return _context.abrupt(\"return\", doc);\n\n            case 39:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[8, 14]]);\n    }));\n    return _loadDocument.apply(this, arguments);\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise(function (resolve, reject) {\n    request(options, function (err, res, body) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          res: res,\n          body: body\n        });\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/home/alexandre/dev/classe-dehors/frontend/node_modules/jsonld/lib/documentLoaders/node.js"],"names":["require","parseLinkHeader","buildHeaders","LINK_HEADER_CONTEXT","JsonLdError","RequestQueue","prependBase","module","exports","strictSSL","maxRedirects","headers","secure","request","http","queue","wrapLoader","url","loadDocument","redirects","indexOf","code","doc","alternate","_request","followRedirect","result","cause","res","body","contextUrl","documentUrl","document","statusText","STATUS_CODES","statusCode","httpStatusCode","link","linkHeaders","linkedContext","Array","isArray","target","type","match","location","length","push","options","Promise","resolve","reject","err"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {parseLinkHeader, buildHeaders} = require('../util');\nconst {LINK_HEADER_CONTEXT} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\nconst {prependBase} = require('../url');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `axios`\n  request = request || require('request');\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let result;\n    let alternate = null;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    const {res, body} = result;\n\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if(res.statusCode >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${statusText}`,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode\n        });\n    }\n\n    // handle Link Header\n    if(res.headers.link &&\n      res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(res.headers.link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if(Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders['alternate'];\n      if(alternate &&\n        alternate.type == 'application/ld+json' &&\n        !(res.headers['content-type'] || '')\n          .match(/^application\\/(\\w*\\+)?json$/)) {\n        res.headers.location = prependBase(url, alternate.target);\n      }\n    }\n\n    // handle redirect\n    if((alternate ||\n      res.statusCode >= 300 && res.statusCode < 400) && res.headers.location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if(err) {\n        reject(err);\n      } else {\n        resolve({res, body});\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}