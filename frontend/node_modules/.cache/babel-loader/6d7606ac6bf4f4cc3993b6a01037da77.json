{"ast":null,"code":"/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _toConsumableArray = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar util = require('./util');\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./url'),\n    _isAbsoluteIri = _require2.isAbsolute,\n    _isRelativeIri = _require2.isRelative,\n    prependBase = _require2.prependBase;\n\nvar _require3 = require('./util'),\n    _asArray = _require3.asArray,\n    _compareShortestLeast = _require3.compareShortestLeast;\n\nvar INITIAL_CONTEXT_CACHE = new Map();\nvar INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\nvar KEYWORD_PATTERN = /^@[a-zA-Z]+$/;\nvar api = {};\nmodule.exports = api;\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\n\napi.process = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var activeCtx, localCtx, options, _ref$propagate, propagate, _ref$overrideProtecte, overrideProtected, _ref$cycles, cycles, ctxs, resolved, rval, _iterator, _step, resolvedContext, ctx, protectedMode, _processed, oldActiveCtx, _i, _Object$entries, _Object$entries$_i, term, _protected, processed, defined, base, value, _value, _value2, _value3, _value4, resolvedImport, processedImport, importCtx, key, _key, keyCtx, process, url;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            activeCtx = _ref.activeCtx, localCtx = _ref.localCtx, options = _ref.options, _ref$propagate = _ref.propagate, propagate = _ref$propagate === void 0 ? true : _ref$propagate, _ref$overrideProtecte = _ref.overrideProtected, overrideProtected = _ref$overrideProtecte === void 0 ? false : _ref$overrideProtecte, _ref$cycles = _ref.cycles, cycles = _ref$cycles === void 0 ? new Set() : _ref$cycles;\n\n            // normalize local context to an array of @context objects\n            if (_isObject(localCtx) && '@context' in localCtx && _isArray(localCtx['@context'])) {\n              localCtx = localCtx['@context'];\n            }\n\n            ctxs = _asArray(localCtx); // no contexts in array, return current active context w/o changes\n\n            if (!(ctxs.length === 0)) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", activeCtx);\n\n          case 5:\n            _context.next = 7;\n            return options.contextResolver.resolve({\n              activeCtx: activeCtx,\n              context: localCtx,\n              documentLoader: options.documentLoader,\n              base: options.base\n            });\n\n          case 7:\n            resolved = _context.sent;\n\n            // override propagate if first resolved context has `@propagate`\n            if (_isObject(resolved[0].document) && typeof resolved[0].document['@propagate'] === 'boolean') {\n              // retrieve early, error checking done later\n              propagate = resolved[0].document['@propagate'];\n            } // process each context in order, update active context\n            // on each iteration to ensure proper caching\n\n\n            rval = activeCtx; // track the previous context\n            // if not propagating, make sure rval has a previous context\n\n            if (!propagate && !rval.previousContext) {\n              // clone `rval` context before updating\n              rval = rval.clone();\n              rval.previousContext = activeCtx;\n            }\n\n            _iterator = _createForOfIteratorHelper(resolved);\n            _context.prev = 12;\n\n            _iterator.s();\n\n          case 14:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 164;\n              break;\n            }\n\n            resolvedContext = _step.value;\n            ctx = resolvedContext.document; // update active context to one computed from last iteration\n\n            activeCtx = rval; // reset to initial context\n\n            if (!(ctx === null)) {\n              _context.next = 40;\n              break;\n            }\n\n            if (!(!overrideProtected && Object.keys(activeCtx.protected).length !== 0)) {\n              _context.next = 38;\n              break;\n            }\n\n            protectedMode = options && options.protectedMode || 'error';\n\n            if (!(protectedMode === 'error')) {\n              _context.next = 25;\n              break;\n            }\n\n            throw new JsonLdError('Tried to nullify a context with protected terms outside of ' + 'a term definition.', 'jsonld.SyntaxError', {\n              code: 'invalid context nullification'\n            });\n\n          case 25:\n            if (!(protectedMode === 'warn')) {\n              _context.next = 37;\n              break;\n            }\n\n            // FIXME: remove logging and use a handler\n            console.warn('WARNING: invalid context nullification'); // get processed context from cache if available\n\n            _processed = resolvedContext.getProcessed(activeCtx);\n\n            if (!_processed) {\n              _context.next = 31;\n              break;\n            }\n\n            rval = activeCtx = _processed;\n            return _context.abrupt(\"continue\", 162);\n\n          case 31:\n            oldActiveCtx = activeCtx; // copy all protected term definitions to fresh initial context\n\n            rval = activeCtx = api.getInitialContext(options).clone();\n\n            for (_i = 0, _Object$entries = Object.entries(oldActiveCtx.protected); _i < _Object$entries.length; _i++) {\n              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), term = _Object$entries$_i[0], _protected = _Object$entries$_i[1];\n\n              if (_protected) {\n                activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);\n              }\n            }\n\n            activeCtx.protected = util.clone(oldActiveCtx.protected); // cache processed result\n\n            resolvedContext.setProcessed(oldActiveCtx, rval);\n            return _context.abrupt(\"continue\", 162);\n\n          case 37:\n            throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {\n              code: 'invalid protected mode',\n              context: localCtx,\n              protectedMode: protectedMode\n            });\n\n          case 38:\n            rval = activeCtx = api.getInitialContext(options).clone();\n            return _context.abrupt(\"continue\", 162);\n\n          case 40:\n            // get processed context from cache if available\n            processed = resolvedContext.getProcessed(activeCtx);\n\n            if (!processed) {\n              _context.next = 44;\n              break;\n            }\n\n            rval = activeCtx = processed;\n            return _context.abrupt(\"continue\", 162);\n\n          case 44:\n            // dereference @context key if present\n            if (_isObject(ctx) && '@context' in ctx) {\n              ctx = ctx['@context'];\n            } // context must be an object by now, all URLs retrieved before this call\n\n\n            if (_isObject(ctx)) {\n              _context.next = 47;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {\n              code: 'invalid local context',\n              context: ctx\n            });\n\n          case 47:\n            // TODO: there is likely a `previousContext` cloning optimization that\n            // could be applied here (no need to copy it under certain conditions)\n            // clone context before updating it\n            rval = rval.clone(); // define context mappings for keys in local context\n\n            defined = new Map(); // handle @version\n\n            if (!('@version' in ctx)) {\n              _context.next = 57;\n              break;\n            }\n\n            if (!(ctx['@version'] !== 1.1)) {\n              _context.next = 52;\n              break;\n            }\n\n            throw new JsonLdError('Unsupported JSON-LD version: ' + ctx['@version'], 'jsonld.UnsupportedVersion', {\n              code: 'invalid @version value',\n              context: ctx\n            });\n\n          case 52:\n            if (!(activeCtx.processingMode && activeCtx.processingMode === 'json-ld-1.0')) {\n              _context.next = 54;\n              break;\n            }\n\n            throw new JsonLdError('@version: ' + ctx['@version'] + ' not compatible with ' + activeCtx.processingMode, 'jsonld.ProcessingModeConflict', {\n              code: 'processing mode conflict',\n              context: ctx\n            });\n\n          case 54:\n            rval.processingMode = 'json-ld-1.1';\n            rval['@version'] = ctx['@version'];\n            defined.set('@version', true);\n\n          case 57:\n            // if not set explicitly, set processingMode to \"json-ld-1.1\"\n            rval.processingMode = rval.processingMode || activeCtx.processingMode; // handle @base\n\n            if (!('@base' in ctx)) {\n              _context.next = 70;\n              break;\n            }\n\n            base = ctx['@base'];\n\n            if (!(base === null || _isAbsoluteIri(base))) {\n              _context.next = 63;\n              break;\n            }\n\n            _context.next = 68;\n            break;\n\n          case 63:\n            if (!_isRelativeIri(base)) {\n              _context.next = 67;\n              break;\n            }\n\n            base = prependBase(rval['@base'], base);\n            _context.next = 68;\n            break;\n\n          case 67:\n            throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@base\" in a ' + '@context must be an absolute IRI, a relative IRI, or null.', 'jsonld.SyntaxError', {\n              code: 'invalid base IRI',\n              context: ctx\n            });\n\n          case 68:\n            rval['@base'] = base;\n            defined.set('@base', true);\n\n          case 70:\n            if (!('@vocab' in ctx)) {\n              _context.next = 86;\n              break;\n            }\n\n            value = ctx['@vocab'];\n\n            if (!(value === null)) {\n              _context.next = 76;\n              break;\n            }\n\n            delete rval['@vocab'];\n            _context.next = 85;\n            break;\n\n          case 76:\n            if (_isString(value)) {\n              _context.next = 80;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@vocab\" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {\n              code: 'invalid vocab mapping',\n              context: ctx\n            });\n\n          case 80:\n            if (!(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0))) {\n              _context.next = 84;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@vocab\" in a ' + '@context must be an absolute IRI.', 'jsonld.SyntaxError', {\n              code: 'invalid vocab mapping',\n              context: ctx\n            });\n\n          case 84:\n            rval['@vocab'] = _expandIri(rval, value, {\n              vocab: true,\n              base: true\n            }, undefined, undefined, options);\n\n          case 85:\n            defined.set('@vocab', true);\n\n          case 86:\n            if (!('@language' in ctx)) {\n              _context.next = 98;\n              break;\n            }\n\n            _value = ctx['@language'];\n\n            if (!(_value === null)) {\n              _context.next = 92;\n              break;\n            }\n\n            delete rval['@language'];\n            _context.next = 97;\n            break;\n\n          case 92:\n            if (_isString(_value)) {\n              _context.next = 96;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@language\" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {\n              code: 'invalid default language',\n              context: ctx\n            });\n\n          case 96:\n            rval['@language'] = _value.toLowerCase();\n\n          case 97:\n            defined.set('@language', true);\n\n          case 98:\n            if (!('@direction' in ctx)) {\n              _context.next = 112;\n              break;\n            }\n\n            _value2 = ctx['@direction'];\n\n            if (!(activeCtx.processingMode === 'json-ld-1.0')) {\n              _context.next = 102;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @direction not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {\n              code: 'invalid context member',\n              context: ctx\n            });\n\n          case 102:\n            if (!(_value2 === null)) {\n              _context.next = 106;\n              break;\n            }\n\n            delete rval['@direction'];\n            _context.next = 111;\n            break;\n\n          case 106:\n            if (!(_value2 !== 'ltr' && _value2 !== 'rtl')) {\n              _context.next = 110;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@direction\" in a ' + '@context must be null, \"ltr\", or \"rtl\".', 'jsonld.SyntaxError', {\n              code: 'invalid base direction',\n              context: ctx\n            });\n\n          case 110:\n            rval['@direction'] = _value2;\n\n          case 111:\n            defined.set('@direction', true);\n\n          case 112:\n            if (!('@propagate' in ctx)) {\n              _context.next = 119;\n              break;\n            }\n\n            _value3 = ctx['@propagate'];\n\n            if (!(activeCtx.processingMode === 'json-ld-1.0')) {\n              _context.next = 116;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @propagate not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {\n              code: 'invalid context entry',\n              context: ctx\n            });\n\n          case 116:\n            if (!(typeof _value3 !== 'boolean')) {\n              _context.next = 118;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @propagate value must be a boolean.', 'jsonld.SyntaxError', {\n              code: 'invalid @propagate value',\n              context: localCtx\n            });\n\n          case 118:\n            defined.set('@propagate', true);\n\n          case 119:\n            if (!('@import' in ctx)) {\n              _context.next = 141;\n              break;\n            }\n\n            _value4 = ctx['@import'];\n\n            if (!(activeCtx.processingMode === 'json-ld-1.0')) {\n              _context.next = 123;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @import not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {\n              code: 'invalid context entry',\n              context: ctx\n            });\n\n          case 123:\n            if (_isString(_value4)) {\n              _context.next = 125;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @import must be a string.', 'jsonld.SyntaxError', {\n              code: 'invalid @import value',\n              context: localCtx\n            });\n\n          case 125:\n            _context.next = 127;\n            return options.contextResolver.resolve({\n              activeCtx: activeCtx,\n              context: _value4,\n              documentLoader: options.documentLoader,\n              base: options.base\n            });\n\n          case 127:\n            resolvedImport = _context.sent;\n\n            if (!(resolvedImport.length !== 1)) {\n              _context.next = 130;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; @import must reference a single context.', 'jsonld.SyntaxError', {\n              code: 'invalid remote context',\n              context: localCtx\n            });\n\n          case 130:\n            processedImport = resolvedImport[0].getProcessed(activeCtx);\n\n            if (!processedImport) {\n              _context.next = 135;\n              break;\n            }\n\n            // Note: if the same context were used in this active context\n            // as a reference context, then processed_input might not\n            // be a dict.\n            ctx = processedImport;\n            _context.next = 140;\n            break;\n\n          case 135:\n            importCtx = resolvedImport[0].document;\n\n            if (!('@import' in importCtx)) {\n              _context.next = 138;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax: ' + 'imported context must not include @import.', 'jsonld.SyntaxError', {\n              code: 'invalid context entry',\n              context: localCtx\n            });\n\n          case 138:\n            // merge ctx into importCtx and replace rval with the result\n            for (key in importCtx) {\n              if (!ctx.hasOwnProperty(key)) {\n                ctx[key] = importCtx[key];\n              }\n            } // Note: this could potenially conflict if the import\n            // were used in the same active context as a referenced\n            // context and an import. In this case, we\n            // could override the cached result, but seems unlikely.\n\n\n            resolvedImport[0].setProcessed(activeCtx, ctx);\n\n          case 140:\n            defined.set('@import', true);\n\n          case 141:\n            // handle @protected; determine whether this sub-context is declaring\n            // all its terms to be \"protected\" (exceptions can be made on a\n            // per-definition basis)\n            defined.set('@protected', ctx['@protected'] || false); // process all other keys\n\n            _context.t0 = _regeneratorRuntime.keys(ctx);\n\n          case 143:\n            if ((_context.t1 = _context.t0()).done) {\n              _context.next = 161;\n              break;\n            }\n\n            _key = _context.t1.value;\n            api.createTermDefinition({\n              activeCtx: rval,\n              localCtx: ctx,\n              term: _key,\n              defined: defined,\n              options: options,\n              overrideProtected: overrideProtected\n            });\n\n            if (!(_isObject(ctx[_key]) && '@context' in ctx[_key])) {\n              _context.next = 159;\n              break;\n            }\n\n            keyCtx = ctx[_key]['@context'];\n            process = true;\n\n            if (_isString(keyCtx)) {\n              url = prependBase(options.base, keyCtx); // track processed contexts to avoid scoped context recursion\n\n              if (cycles.has(url)) {\n                process = false;\n              } else {\n                cycles.add(url);\n              }\n            } // parse context to validate\n\n\n            if (!process) {\n              _context.next = 159;\n              break;\n            }\n\n            _context.prev = 151;\n            _context.next = 154;\n            return api.process({\n              activeCtx: rval.clone(),\n              localCtx: ctx[_key]['@context'],\n              overrideProtected: true,\n              options: options,\n              cycles: cycles\n            });\n\n          case 154:\n            _context.next = 159;\n            break;\n\n          case 156:\n            _context.prev = 156;\n            _context.t2 = _context[\"catch\"](151);\n            throw new JsonLdError('Invalid JSON-LD syntax; invalid scoped context.', 'jsonld.SyntaxError', {\n              code: 'invalid scoped context',\n              context: ctx[_key]['@context'],\n              term: _key\n            });\n\n          case 159:\n            _context.next = 143;\n            break;\n\n          case 161:\n            // cache processed result\n            resolvedContext.setProcessed(activeCtx, rval);\n\n          case 162:\n            _context.next = 14;\n            break;\n\n          case 164:\n            _context.next = 169;\n            break;\n\n          case 166:\n            _context.prev = 166;\n            _context.t3 = _context[\"catch\"](12);\n\n            _iterator.e(_context.t3);\n\n          case 169:\n            _context.prev = 169;\n\n            _iterator.f();\n\n            return _context.finish(169);\n\n          case 172:\n            return _context.abrupt(\"return\", rval);\n\n          case 173:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[12, 166, 169, 172], [151, 156]]);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\n\n\napi.createTermDefinition = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n      localCtx = _ref3.localCtx,\n      term = _ref3.term,\n      defined = _ref3.defined,\n      options = _ref3.options,\n      _ref3$overrideProtect = _ref3.overrideProtected,\n      overrideProtected = _ref3$overrideProtect === void 0 ? false : _ref3$overrideProtect;\n\n  if (defined.has(term)) {\n    // term already defined\n    if (defined.get(term)) {\n      return;\n    } // cycle detected\n\n\n    throw new JsonLdError('Cyclical context definition detected.', 'jsonld.CyclicalContext', {\n      code: 'cyclic IRI mapping',\n      context: localCtx,\n      term: term\n    });\n  } // now defining term\n\n\n  defined.set(term, false); // get context term value\n\n  var value;\n\n  if (localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  if (term === '@type' && _isObject(value) && (value['@container'] || '@set') === '@set' && api.processingMode(activeCtx, 1.1)) {\n    var _validKeys = ['@container', '@id', '@protected'];\n    var keys = Object.keys(value);\n\n    if (keys.length === 0 || keys.some(function (k) {\n      return !_validKeys.includes(k);\n    })) {\n      throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {\n        code: 'keyword redefinition',\n        context: localCtx,\n        term: term\n      });\n    }\n  } else if (api.isKeyword(term)) {\n    throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {\n      code: 'keyword redefinition',\n      context: localCtx,\n      term: term\n    });\n  } else if (term.match(KEYWORD_PATTERN)) {\n    // FIXME: remove logging and use a handler\n    console.warn('WARNING: terms beginning with \"@\" are reserved' + ' for future use and ignored', {\n      term: term\n    });\n    return;\n  } else if (term === '') {\n    throw new JsonLdError('Invalid JSON-LD syntax; a term cannot be an empty string.', 'jsonld.SyntaxError', {\n      code: 'invalid term definition',\n      context: localCtx\n    });\n  } // keep reference to previous mapping for potential `@protected` check\n\n\n  var previousMapping = activeCtx.mappings.get(term); // remove old mapping\n\n  if (activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  } // convert short-hand value to object w/@id\n\n\n  var simpleTerm = false;\n\n  if (_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {\n      '@id': value\n    };\n  }\n\n  if (!_isObject(value)) {\n    throw new JsonLdError('Invalid JSON-LD syntax; @context term values must be ' + 'strings or objects.', 'jsonld.SyntaxError', {\n      code: 'invalid term definition',\n      context: localCtx\n    });\n  } // create new mapping\n\n\n  var mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false; // make sure term definition only has expected keywords\n\n  var validKeys = ['@container', '@id', '@language', '@reverse', '@type']; // JSON-LD 1.1 support\n\n  if (api.processingMode(activeCtx, 1.1)) {\n    validKeys.push('@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n\n  for (var kw in value) {\n    if (!validKeys.includes(kw)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a term definition must not contain ' + kw, 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n  } // always compute whether term has a colon as an optimization for\n  // _compactIri\n\n\n  var colon = term.indexOf(':');\n  mapping._termHasColon = colon > 0;\n\n  if ('@reverse' in value) {\n    if ('@id' in value) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @id.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n\n    if ('@nest' in value) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @nest.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n\n    var reverse = value['@reverse'];\n\n    if (!_isString(reverse)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be a string.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n\n    if (!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' + ' for future use and ignored', {\n        reverse: reverse\n      });\n\n      if (previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n\n      return;\n    } // expand and add @id mapping\n\n\n    var _id = _expandIri(activeCtx, reverse, {\n      vocab: true,\n      base: false\n    }, localCtx, defined, options);\n\n    if (!_isAbsoluteIri(_id)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be an ' + 'absolute IRI or a blank node identifier.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n\n    mapping['@id'] = _id;\n    mapping.reverse = true;\n  } else if ('@id' in value) {\n    var _id2 = value['@id'];\n\n    if (_id2 && !_isString(_id2)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an array ' + 'of strings or a string.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n\n    if (_id2 === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if (!api.isKeyword(_id2) && _id2.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' + ' for future use and ignored', {\n        id: _id2\n      });\n\n      if (previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n\n      return;\n    } else if (_id2 !== term) {\n      // expand and add @id mapping\n      _id2 = _expandIri(activeCtx, _id2, {\n        vocab: true,\n        base: false\n      }, localCtx, defined, options);\n\n      if (!_isAbsoluteIri(_id2) && !api.isKeyword(_id2)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an ' + 'absolute IRI, a blank node identifier, or a keyword.', 'jsonld.SyntaxError', {\n          code: 'invalid IRI mapping',\n          context: localCtx\n        });\n      } // if term has the form of an IRI it must map the same\n\n\n      if (term.match(/(?::[^:])|\\//)) {\n        var termDefined = new Map(defined).set(term, true);\n\n        var termIri = _expandIri(activeCtx, term, {\n          vocab: true,\n          base: false\n        }, localCtx, termDefined, options);\n\n        if (termIri !== _id2) {\n          throw new JsonLdError('Invalid JSON-LD syntax; term in form of IRI must ' + 'expand to definition.', 'jsonld.SyntaxError', {\n            code: 'invalid IRI mapping',\n            context: localCtx\n          });\n        }\n      }\n\n      mapping['@id'] = _id2; // indicate if this term may be used as a compact IRI prefix\n\n      mapping._prefix = simpleTerm && !mapping._termHasColon && _id2.match(/[:\\/\\?#\\[\\]@]$/);\n    }\n  }\n\n  if (!('@id' in mapping)) {\n    // see if the term has a prefix\n    if (mapping._termHasColon) {\n      var prefix = term.substr(0, colon);\n\n      if (localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx: activeCtx,\n          localCtx: localCtx,\n          term: prefix,\n          defined: defined,\n          options: options\n        });\n      }\n\n      if (activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        var suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if (term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if (!('@vocab' in activeCtx)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; @context terms must define an @id.', 'jsonld.SyntaxError', {\n          code: 'invalid IRI mapping',\n          context: localCtx,\n          term: term\n        });\n      } // prepend vocab to term\n\n\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  } // Handle term protection\n\n\n  if (value['@protected'] === true || defined.get('@protected') === true && value['@protected'] !== false) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  } // IRI mapping now defined\n\n\n  defined.set(term, true);\n\n  if ('@type' in value) {\n    var type = value['@type'];\n\n    if (!_isString(type)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be a string.', 'jsonld.SyntaxError', {\n        code: 'invalid type mapping',\n        context: localCtx\n      });\n    }\n\n    if (type === '@json' || type === '@none') {\n      if (api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must not be ' + \"\\\"\".concat(type, \"\\\" in JSON-LD 1.0 mode.\"), 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n    } else if (type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(activeCtx, type, {\n        vocab: true,\n        base: false\n      }, localCtx, defined, options);\n\n      if (!_isAbsoluteIri(type)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an ' + 'absolute IRI.', 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n\n      if (type.indexOf('_:') === 0) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an IRI, ' + 'not a blank node identifier.', 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n    } // add @type to mapping\n\n\n    mapping['@type'] = type;\n  }\n\n  if ('@container' in value) {\n    // normalize container to an array form\n    var container = _isString(value['@container']) ? [value['@container']] : value['@container'] || [];\n    var validContainers = ['@list', '@set', '@index', '@language'];\n    var isValid = true;\n    var hasSet = container.includes('@set'); // JSON-LD 1.1 support\n\n    if (api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type'); // check container length\n\n      if (container.includes('@list')) {\n        if (container.length !== 1) {\n          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @list must ' + 'have no other values', 'jsonld.SyntaxError', {\n            code: 'invalid container mapping',\n            context: localCtx\n          });\n        }\n      } else if (container.includes('@graph')) {\n        if (container.some(function (key) {\n          return key !== '@graph' && key !== '@id' && key !== '@index' && key !== '@set';\n        })) {\n          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @graph must ' + 'have no other values other than @id, @index, and @set', 'jsonld.SyntaxError', {\n            code: 'invalid container mapping',\n            context: localCtx\n          });\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n\n      if (container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id'; // type mapping must be either @id or @vocab\n\n        if (!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError('Invalid JSON-LD syntax; container: @type requires @type to be ' + '@id or @vocab.', 'jsonld.SyntaxError', {\n            code: 'invalid type mapping',\n            context: localCtx\n          });\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']); // check container length\n\n      isValid &= container.length <= 1;\n    } // check against valid containers\n\n\n    isValid &= container.every(function (c) {\n      return validContainers.includes(c);\n    }); // @set not allowed with @list\n\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if (!isValid) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value must be ' + 'one of the following: ' + validContainers.join(', '), 'jsonld.SyntaxError', {\n        code: 'invalid container mapping',\n        context: localCtx\n      });\n    }\n\n    if (mapping.reverse && !container.every(function (c) {\n      return ['@index', '@set'].includes(c);\n    })) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value for a @reverse ' + 'type definition must be @index or @set.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    } // add @container to mapping\n\n\n    mapping['@container'] = container;\n  } // property indexing\n\n\n  if ('@index' in value) {\n    if (!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @index without @index in @container: ' + \"\\\"\".concat(value['@index'], \"\\\" on term \\\"\").concat(term, \"\\\".\"), 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n\n    if (!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @index must expand to an IRI: ' + \"\\\"\".concat(value['@index'], \"\\\" on term \\\"\").concat(term, \"\\\".\"), 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n\n    mapping['@index'] = value['@index'];\n  } // scoped contexts\n\n\n  if ('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if ('@language' in value && !('@type' in value)) {\n    var language = value['@language'];\n\n    if (language !== null && !_isString(language)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @language value must be ' + 'a string or null.', 'jsonld.SyntaxError', {\n        code: 'invalid language mapping',\n        context: localCtx\n      });\n    } // add @language to mapping\n\n\n    if (language !== null) {\n      language = language.toLowerCase();\n    }\n\n    mapping['@language'] = language;\n  } // term may be used as a prefix\n\n\n  if ('@prefix' in value) {\n    if (term.match(/:|\\//)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @prefix used on a compact IRI term', 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n\n    if (api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError('Invalid JSON-LD syntax; keywords may not be used as prefixes', 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n\n    if (typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context value for @prefix must be boolean', 'jsonld.SyntaxError', {\n        code: 'invalid @prefix value',\n        context: localCtx\n      });\n    }\n  }\n\n  if ('@direction' in value) {\n    var direction = value['@direction'];\n\n    if (direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError('Invalid JSON-LD syntax; @direction value must be ' + 'null, \"ltr\", or \"rtl\".', 'jsonld.SyntaxError', {\n        code: 'invalid base direction',\n        context: localCtx\n      });\n    }\n\n    mapping['@direction'] = direction;\n  }\n\n  if ('@nest' in value) {\n    var nest = value['@nest'];\n\n    if (!_isString(nest) || nest !== '@nest' && nest.indexOf('@') === 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @nest value must be ' + 'a string which is not a keyword other than @nest.', 'jsonld.SyntaxError', {\n        code: 'invalid @nest value',\n        context: localCtx\n      });\n    }\n\n    mapping['@nest'] = nest;\n  } // disallow aliasing @context and @preserve\n\n\n  var id = mapping['@id'];\n\n  if (id === '@context' || id === '@preserve') {\n    throw new JsonLdError('Invalid JSON-LD syntax; @context and @preserve cannot be aliased.', 'jsonld.SyntaxError', {\n      code: 'invalid keyword alias',\n      context: localCtx\n    });\n  } // Check for overriding protected terms\n\n\n  if (previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n\n    if (!_deepCompare(previousMapping, mapping)) {\n      var protectedMode = options && options.protectedMode || 'error';\n\n      if (protectedMode === 'error') {\n        throw new JsonLdError('Invalid JSON-LD syntax; tried to redefine a protected term.', 'jsonld.SyntaxError', {\n          code: 'protected term redefinition',\n          context: localCtx,\n          term: term\n        });\n      } else if (protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {\n          term: term\n        });\n        return;\n      }\n\n      throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {\n        code: 'invalid protected mode',\n        context: localCtx,\n        term: term,\n        protectedMode: protectedMode\n      });\n    }\n  }\n};\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\napi.expandIri = function (activeCtx, value, relativeTo, options) {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined, options);\n};\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if (value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  } // ignore non-keyword things that look like a keyword\n\n\n  if (value.match(KEYWORD_PATTERN)) {\n    return null;\n  } // define term dependency if not defined\n\n\n  if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx: activeCtx,\n      localCtx: localCtx,\n      term: value,\n      defined: defined,\n      options: options\n    });\n  }\n\n  relativeTo = relativeTo || {};\n\n  if (relativeTo.vocab) {\n    var mapping = activeCtx.mappings.get(value); // value is explicitly ignored with a null mapping\n\n    if (mapping === null) {\n      return null;\n    }\n\n    if (_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  } // split value into prefix:suffix\n\n\n  var colon = value.indexOf(':');\n\n  if (colon > 0) {\n    var prefix = value.substr(0, colon);\n    var suffix = value.substr(colon + 1); // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n\n    if (prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    } // prefix dependency not defined, define it\n\n\n    if (localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx: activeCtx,\n        localCtx: localCtx,\n        term: prefix,\n        defined: defined,\n        options: options\n      });\n    } // use mapping if prefix is defined\n\n\n    var _mapping = activeCtx.mappings.get(prefix);\n\n    if (_mapping && _mapping._prefix) {\n      return _mapping['@id'] + suffix;\n    } // already absolute IRI\n\n\n    if (_isAbsoluteIri(value)) {\n      return value;\n    }\n  } // prepend vocab\n\n\n  if (relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  } // prepend base\n\n\n  if (relativeTo.base && '@base' in activeCtx) {\n    if (activeCtx['@base']) {\n      // The null case preserves value as potentially relative\n      return prependBase(prependBase(options.base, activeCtx['@base']), value);\n    }\n  } else if (relativeTo.base) {\n    return prependBase(options.base, value);\n  }\n\n  return value;\n}\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\n\n\napi.getInitialContext = function (options) {\n  var key = JSON.stringify({\n    processingMode: options.processingMode\n  });\n  var cached = INITIAL_CONTEXT_CACHE.get(key);\n\n  if (cached) {\n    return cached;\n  }\n\n  var initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  }; // TODO: consider using LRU cache instead\n\n  if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n\n  function _createInverseContext() {\n    var activeCtx = this; // lazily create inverse\n\n    if (activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n\n    var inverse = activeCtx.inverse = {}; // variables for building fast CURIE map\n\n    var fastCurieMap = activeCtx.fastCurieMap = {};\n    var irisToTerms = {}; // handle default language\n\n    var defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase(); // handle default direction\n\n    var defaultDirection = activeCtx['@direction']; // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n\n    var mappings = activeCtx.mappings;\n\n    var terms = _toConsumableArray(mappings.keys()).sort(_compareShortestLeast);\n\n    var _iterator2 = _createForOfIteratorHelper(terms),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var term = _step2.value;\n        var mapping = mappings.get(term);\n\n        if (mapping === null) {\n          continue;\n        }\n\n        var container = mapping['@container'] || '@none';\n        container = [].concat(container).sort().join('');\n\n        if (mapping['@id'] === null) {\n          continue;\n        } // iterate over every IRI in the mapping\n\n\n        var ids = _asArray(mapping['@id']);\n\n        var _iterator3 = _createForOfIteratorHelper(ids),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var iri = _step3.value;\n            var entry = inverse[iri];\n            var isKeyword = api.isKeyword(iri);\n\n            if (!entry) {\n              // initialize entry\n              inverse[iri] = entry = {};\n\n              if (!isKeyword && !mapping._termHasColon) {\n                // init IRI to term map and fast CURIE prefixes\n                irisToTerms[iri] = [term];\n                var fastCurieEntry = {\n                  iri: iri,\n                  terms: irisToTerms[iri]\n                };\n\n                if (iri[0] in fastCurieMap) {\n                  fastCurieMap[iri[0]].push(fastCurieEntry);\n                } else {\n                  fastCurieMap[iri[0]] = [fastCurieEntry];\n                }\n              }\n            } else if (!isKeyword && !mapping._termHasColon) {\n              // add IRI to term match\n              irisToTerms[iri].push(term);\n            } // add new entry\n\n\n            if (!entry[container]) {\n              entry[container] = {\n                '@language': {},\n                '@type': {},\n                '@any': {}\n              };\n            }\n\n            entry = entry[container];\n\n            _addPreferredTerm(term, entry['@any'], '@none');\n\n            if (mapping.reverse) {\n              // term is preferred for values using @reverse\n              _addPreferredTerm(term, entry['@type'], '@reverse');\n            } else if (mapping['@type'] === '@none') {\n              _addPreferredTerm(term, entry['@any'], '@none');\n\n              _addPreferredTerm(term, entry['@language'], '@none');\n\n              _addPreferredTerm(term, entry['@type'], '@none');\n            } else if ('@type' in mapping) {\n              // term is preferred for values using specific type\n              _addPreferredTerm(term, entry['@type'], mapping['@type']);\n            } else if ('@language' in mapping && '@direction' in mapping) {\n              // term is preferred for values using specific language and direction\n              var language = mapping['@language'];\n              var direction = mapping['@direction'];\n\n              if (language && direction) {\n                _addPreferredTerm(term, entry['@language'], \"\".concat(language, \"_\").concat(direction).toLowerCase());\n              } else if (language) {\n                _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n              } else if (direction) {\n                _addPreferredTerm(term, entry['@language'], \"_\".concat(direction));\n              } else {\n                _addPreferredTerm(term, entry['@language'], '@null');\n              }\n            } else if ('@language' in mapping) {\n              _addPreferredTerm(term, entry['@language'], (mapping['@language'] || '@null').toLowerCase());\n            } else if ('@direction' in mapping) {\n              if (mapping['@direction']) {\n                _addPreferredTerm(term, entry['@language'], \"_\".concat(mapping['@direction']));\n              } else {\n                _addPreferredTerm(term, entry['@language'], '@none');\n              }\n            } else if (defaultDirection) {\n              _addPreferredTerm(term, entry['@language'], \"_\".concat(defaultDirection));\n\n              _addPreferredTerm(term, entry['@language'], '@none');\n\n              _addPreferredTerm(term, entry['@type'], '@none');\n            } else {\n              // add entries for no type and no language\n              _addPreferredTerm(term, entry['@language'], defaultLanguage);\n\n              _addPreferredTerm(term, entry['@language'], '@none');\n\n              _addPreferredTerm(term, entry['@type'], '@none');\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } // build fast CURIE map\n\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    for (var _key2 in fastCurieMap) {\n      _buildIriMap(fastCurieMap, _key2, 1);\n    }\n\n    return inverse;\n  }\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n\n\n  function _buildIriMap(iriMap, key, idx) {\n    var entries = iriMap[key];\n    var next = iriMap[key] = {};\n    var iri;\n    var letter;\n\n    var _iterator4 = _createForOfIteratorHelper(entries),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var entry = _step4.value;\n        iri = entry.iri;\n\n        if (idx >= iri.length) {\n          letter = '';\n        } else {\n          letter = iri[idx];\n        }\n\n        if (letter in next) {\n          next[letter].push(entry);\n        } else {\n          next[letter] = [entry];\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    for (var _key3 in next) {\n      if (_key3 === '') {\n        continue;\n      }\n\n      _buildIriMap(next, _key3, idx + 1);\n    }\n  }\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n\n\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if (!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n\n\n  function _cloneActiveContext() {\n    var child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n\n    if (this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n\n    child.revertToPreviousContext = this.revertToPreviousContext;\n\n    if ('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n\n    if ('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n\n    if ('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n\n    return child;\n  }\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n\n\n  function _revertToPreviousContext() {\n    if (!this.previousContext) {\n      return this;\n    }\n\n    return this.previousContext.clone();\n  }\n};\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\n\n\napi.getContextValue = function (ctx, key, type) {\n  // invalid key\n  if (key === null) {\n    if (type === '@context') {\n      return undefined;\n    }\n\n    return null;\n  } // get specific entry information\n\n\n  if (ctx.mappings.has(key)) {\n    var entry = ctx.mappings.get(key);\n\n    if (_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n\n    if (entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  } // get default language\n\n\n  if (type === '@language' && type in ctx) {\n    return ctx[type];\n  } // get default direction\n\n\n  if (type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n\n  if (type === '@context') {\n    return undefined;\n  }\n\n  return null;\n};\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\n\n\napi.processingMode = function (activeCtx, version) {\n  if (version.toString() >= '1.1') {\n    return !activeCtx.processingMode || activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\n\n\napi.isKeyword = function (v) {\n  if (!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n\n  switch (v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n\n  return false;\n};\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if (!(x1 && typeof x1 === 'object') || !(x2 && typeof x2 === 'object')) {\n    return x1 === x2;\n  } // x1 and x2 are objects (also potentially arrays)\n\n\n  var x1Array = Array.isArray(x1);\n\n  if (x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n\n  if (x1Array) {\n    if (x1.length !== x2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < x1.length; ++i) {\n      if (!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } // x1 and x2 are non-array objects\n\n\n  var k1s = Object.keys(x1);\n  var k2s = Object.keys(x2);\n\n  if (k1s.length !== k2s.length) {\n    return false;\n  }\n\n  for (var k1 in x1) {\n    var v1 = x1[k1];\n    var v2 = x2[k1]; // special case: `@container` can be in any order\n\n    if (k1 === '@container') {\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n\n    if (!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/alexandre/dev/classe-dehors/frontend/node_modules/jsonld/lib/context.js"],"names":["util","require","JsonLdError","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isAbsoluteIri","isAbsolute","_isRelativeIri","isRelative","prependBase","_asArray","asArray","_compareShortestLeast","compareShortestLeast","INITIAL_CONTEXT_CACHE","Map","INITIAL_CONTEXT_CACHE_MAX_SIZE","KEYWORD_PATTERN","api","module","exports","process","activeCtx","localCtx","options","propagate","overrideProtected","cycles","Set","ctxs","length","contextResolver","resolve","context","documentLoader","base","resolved","document","rval","previousContext","clone","resolvedContext","ctx","Object","keys","protected","protectedMode","code","console","warn","processed","getProcessed","oldActiveCtx","getInitialContext","entries","term","_protected","mappings","setProcessed","defined","processingMode","set","value","_expandIri","vocab","undefined","toLowerCase","resolvedImport","processedImport","importCtx","key","hasOwnProperty","createTermDefinition","keyCtx","url","has","add","get","validKeys","some","k","includes","isKeyword","match","previousMapping","delete","simpleTerm","mapping","reverse","push","kw","colon","indexOf","_termHasColon","id","termDefined","termIri","_prefix","prefix","substr","suffix","type","container","validContainers","isValid","hasSet","every","c","join","language","direction","nest","_deepCompare","expandIri","relativeTo","JSON","stringify","cached","initialContext","inverse","getInverse","_createInverseContext","_cloneActiveContext","revertToPreviousContext","_revertToPreviousContext","size","clear","fastCurieMap","irisToTerms","defaultLanguage","defaultDirection","terms","sort","concat","ids","iri","entry","fastCurieEntry","_addPreferredTerm","_buildIriMap","iriMap","idx","next","letter","typeOrLanguageValue","child","getContextValue","version","toString","v","x1","x2","x1Array","Array","i","k1s","k2s","k1","v1","v2","slice"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isAbsolute: _isAbsoluteIri,\n  isRelative: _isRelativeIri,\n  prependBase\n} = require('./url');\n\nconst {\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst INITIAL_CONTEXT_CACHE = new Map();\nconst INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\nconst KEYWORD_PATTERN = /^@[a-zA-Z]+$/;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\napi.process = async ({\n  activeCtx, localCtx, options,\n  propagate = true,\n  overrideProtected = false,\n  cycles = new Set()\n}) => {\n  // normalize local context to an array of @context objects\n  if(_isObject(localCtx) && '@context' in localCtx &&\n    _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n  const ctxs = _asArray(localCtx);\n\n  // no contexts in array, return current active context w/o changes\n  if(ctxs.length === 0) {\n    return activeCtx;\n  }\n\n  // resolve contexts\n  const resolved = await options.contextResolver.resolve({\n    activeCtx,\n    context: localCtx,\n    documentLoader: options.documentLoader,\n    base: options.base\n  });\n\n  // override propagate if first resolved context has `@propagate`\n  if(_isObject(resolved[0].document) &&\n    typeof resolved[0].document['@propagate'] === 'boolean') {\n    // retrieve early, error checking done later\n    propagate = resolved[0].document['@propagate'];\n  }\n\n  // process each context in order, update active context\n  // on each iteration to ensure proper caching\n  let rval = activeCtx;\n\n  // track the previous context\n  // if not propagating, make sure rval has a previous context\n  if(!propagate && !rval.previousContext) {\n    // clone `rval` context before updating\n    rval = rval.clone();\n    rval.previousContext = activeCtx;\n  }\n\n  for(const resolvedContext of resolved) {\n    let {document: ctx} = resolvedContext;\n\n    // update active context to one computed from last iteration\n    activeCtx = rval;\n\n    // reset to initial context\n    if(ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not allowing overrides (e.g. processing a property term scoped context)\n      if(!overrideProtected &&\n        Object.keys(activeCtx.protected).length !== 0) {\n        const protectedMode = (options && options.protectedMode) || 'error';\n        if(protectedMode === 'error') {\n          throw new JsonLdError(\n            'Tried to nullify a context with protected terms outside of ' +\n            'a term definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context nullification'});\n        } else if(protectedMode === 'warn') {\n          // FIXME: remove logging and use a handler\n          console.warn('WARNING: invalid context nullification');\n\n          // get processed context from cache if available\n          const processed = resolvedContext.getProcessed(activeCtx);\n          if(processed) {\n            rval = activeCtx = processed;\n            continue;\n          }\n\n          const oldActiveCtx = activeCtx;\n          // copy all protected term definitions to fresh initial context\n          rval = activeCtx = api.getInitialContext(options).clone();\n          for(const [term, _protected] of\n            Object.entries(oldActiveCtx.protected)) {\n            if(_protected) {\n              activeCtx.mappings[term] =\n                util.clone(oldActiveCtx.mappings[term]);\n            }\n          }\n          activeCtx.protected = util.clone(oldActiveCtx.protected);\n\n          // cache processed result\n          resolvedContext.setProcessed(oldActiveCtx, rval);\n          continue;\n        }\n        throw new JsonLdError(\n          'Invalid protectedMode.',\n          'jsonld.SyntaxError',\n          {code: 'invalid protected mode', context: localCtx, protectedMode});\n      }\n      rval = activeCtx = api.getInitialContext(options).clone();\n      continue;\n    }\n\n    // get processed context from cache if available\n    const processed = resolvedContext.getProcessed(activeCtx);\n    if(processed) {\n      rval = activeCtx = processed;\n      continue;\n    }\n\n    // dereference @context key if present\n    if(_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // context must be an object by now, all URLs retrieved before this call\n    if(!_isObject(ctx)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context must be an object.',\n        'jsonld.SyntaxError', {code: 'invalid local context', context: ctx});\n    }\n\n    // TODO: there is likely a `previousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n\n    // clone context before updating it\n    rval = rval.clone();\n\n    // define context mappings for keys in local context\n    const defined = new Map();\n\n    // handle @version\n    if('@version' in ctx) {\n      if(ctx['@version'] !== 1.1) {\n        throw new JsonLdError(\n          'Unsupported JSON-LD version: ' + ctx['@version'],\n          'jsonld.UnsupportedVersion',\n          {code: 'invalid @version value', context: ctx});\n      }\n      if(activeCtx.processingMode &&\n        activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          '@version: ' + ctx['@version'] + ' not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.ProcessingModeConflict',\n          {code: 'processing mode conflict', context: ctx});\n      }\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    }\n\n    // if not set explicitly, set processingMode to \"json-ld-1.1\"\n    rval.processingMode =\n      rval.processingMode || activeCtx.processingMode;\n\n    // handle @base\n    if('@base' in ctx) {\n      let base = ctx['@base'];\n\n      if(base === null || _isAbsoluteIri(base)) {\n        // no action\n      } else if(_isRelativeIri(base)) {\n        base = prependBase(rval['@base'], base);\n      } else {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@base\" in a ' +\n          '@context must be an absolute IRI, a relative IRI, or null.',\n          'jsonld.SyntaxError', {code: 'invalid base IRI', context: ctx});\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    }\n\n    // handle @vocab\n    if('@vocab' in ctx) {\n      const value = ctx['@vocab'];\n      if(value === null) {\n        delete rval['@vocab'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else if(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be an absolute IRI.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else {\n        rval['@vocab'] = _expandIri(rval, value, {vocab: true, base: true},\n          undefined, undefined, options);\n      }\n      defined.set('@vocab', true);\n    }\n\n    // handle @language\n    if('@language' in ctx) {\n      const value = ctx['@language'];\n      if(value === null) {\n        delete rval['@language'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@language\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError',\n          {code: 'invalid default language', context: ctx});\n      } else {\n        rval['@language'] = value.toLowerCase();\n      }\n      defined.set('@language', true);\n    }\n\n    // handle @direction\n    if('@direction' in ctx) {\n      const value = ctx['@direction'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @direction not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context member', context: ctx});\n      }\n      if(value === null) {\n        delete rval['@direction'];\n      } else if(value !== 'ltr' && value !== 'rtl') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@direction\" in a ' +\n          '@context must be null, \"ltr\", or \"rtl\".',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', context: ctx});\n      } else {\n        rval['@direction'] = value;\n      }\n      defined.set('@direction', true);\n    }\n\n    // handle @propagate\n    // note: we've already extracted it, here we just do error checking\n    if('@propagate' in ctx) {\n      const value = ctx['@propagate'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(typeof value !== 'boolean') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate value must be a boolean.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @propagate value', context: localCtx});\n      }\n      defined.set('@propagate', true);\n    }\n\n    // handle @import\n    if('@import' in ctx) {\n      const value = ctx['@import'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @import value', context: localCtx});\n      }\n\n      // resolve contexts\n      const resolvedImport = await options.contextResolver.resolve({\n        activeCtx,\n        context: value,\n        documentLoader: options.documentLoader,\n        base: options.base\n      });\n      if(resolvedImport.length !== 1) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must reference a single context.',\n          'jsonld.SyntaxError',\n          {code: 'invalid remote context', context: localCtx});\n      }\n      const processedImport = resolvedImport[0].getProcessed(activeCtx);\n      if(processedImport) {\n        // Note: if the same context were used in this active context\n        // as a reference context, then processed_input might not\n        // be a dict.\n        ctx = processedImport;\n      } else {\n        const importCtx = resolvedImport[0].document;\n        if('@import' in importCtx) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax: ' +\n            'imported context must not include @import.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context entry', context: localCtx});\n        }\n\n        // merge ctx into importCtx and replace rval with the result\n        for(const key in importCtx) {\n          if(!ctx.hasOwnProperty(key)) {\n            ctx[key] = importCtx[key];\n          }\n        }\n\n        // Note: this could potenially conflict if the import\n        // were used in the same active context as a referenced\n        // context and an import. In this case, we\n        // could override the cached result, but seems unlikely.\n        resolvedImport[0].setProcessed(activeCtx, ctx);\n      }\n\n      defined.set('@import', true);\n    }\n\n    // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n    defined.set('@protected', ctx['@protected'] || false);\n\n    // process all other keys\n    for(const key in ctx) {\n      api.createTermDefinition({\n        activeCtx: rval,\n        localCtx: ctx,\n        term: key,\n        defined,\n        options,\n        overrideProtected\n      });\n\n      if(_isObject(ctx[key]) && '@context' in ctx[key]) {\n        const keyCtx = ctx[key]['@context'];\n        let process = true;\n        if(_isString(keyCtx)) {\n          const url = prependBase(options.base, keyCtx);\n          // track processed contexts to avoid scoped context recursion\n          if(cycles.has(url)) {\n            process = false;\n          } else {\n            cycles.add(url);\n          }\n        }\n        // parse context to validate\n        if(process) {\n          try {\n            await api.process({\n              activeCtx: rval.clone(),\n              localCtx: ctx[key]['@context'],\n              overrideProtected: true,\n              options,\n              cycles\n            });\n          } catch(e) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; invalid scoped context.',\n              'jsonld.SyntaxError',\n              {\n                code: 'invalid scoped context',\n                context: ctx[key]['@context'],\n                term: key\n              });\n          }\n        }\n      }\n    }\n\n    // cache processed result\n    resolvedContext.setProcessed(activeCtx, rval);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\napi.createTermDefinition = ({\n  activeCtx,\n  localCtx,\n  term,\n  defined,\n  options,\n  overrideProtected = false,\n}) => {\n  if(defined.has(term)) {\n    // term already defined\n    if(defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError(\n      'Cyclical context definition detected.',\n      'jsonld.CyclicalContext',\n      {code: 'cyclic IRI mapping', context: localCtx, term});\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  // get context term value\n  let value;\n  if(localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  if(term === '@type' &&\n     _isObject(value) &&\n     (value['@container'] || '@set') === '@set' &&\n     api.processingMode(activeCtx, 1.1)) {\n\n    const validKeys = ['@container', '@id', '@protected'];\n    const keys = Object.keys(value);\n    if(keys.length === 0 || keys.some(k => !validKeys.includes(k))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords cannot be overridden.',\n        'jsonld.SyntaxError',\n        {code: 'keyword redefinition', context: localCtx, term});\n    }\n  } else if(api.isKeyword(term)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; keywords cannot be overridden.',\n      'jsonld.SyntaxError',\n      {code: 'keyword redefinition', context: localCtx, term});\n  } else if(term.match(KEYWORD_PATTERN)) {\n    // FIXME: remove logging and use a handler\n    console.warn('WARNING: terms beginning with \"@\" are reserved' +\n      ' for future use and ignored', {term});\n    return;\n  } else if(term === '') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a term cannot be an empty string.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  const previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if(activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // convert short-hand value to object w/@id\n  let simpleTerm = false;\n  if(_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {'@id': value};\n  }\n\n  if(!_isObject(value)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context term values must be ' +\n      'strings or objects.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // create new mapping\n  const mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  const validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if(api.processingMode(activeCtx, 1.1)) {\n    validKeys.push(\n      '@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n\n  for(const kw in value) {\n    if(!validKeys.includes(kw)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a term definition must not contain ' + kw,\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  const colon = term.indexOf(':');\n  mapping._termHasColon = (colon > 0);\n\n  if('@reverse' in value) {\n    if('@id' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @id.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    if('@nest' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @nest.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    const reverse = value['@reverse'];\n    if(!_isString(reverse)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    if(!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' +\n        ' for future use and ignored', {reverse});\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    }\n\n    // expand and add @id mapping\n    const id = _expandIri(\n      activeCtx, reverse, {vocab: true, base: false}, localCtx, defined,\n      options);\n    if(!_isAbsoluteIri(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be an ' +\n        'absolute IRI or a blank node identifier.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    mapping['@id'] = id;\n    mapping.reverse = true;\n  } else if('@id' in value) {\n    let id = value['@id'];\n    if(id && !_isString(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @id value must be an array ' +\n        'of strings or a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    if(id === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if(!api.isKeyword(id) && id.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' +\n        ' for future use and ignored', {id});\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    } else if(id !== term) {\n      // expand and add @id mapping\n      id = _expandIri(\n        activeCtx, id, {vocab: true, base: false}, localCtx, defined, options);\n      if(!_isAbsoluteIri(id) && !api.isKeyword(id)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a @context @id value must be an ' +\n          'absolute IRI, a blank node identifier, or a keyword.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx});\n      }\n\n      // if term has the form of an IRI it must map the same\n      if(term.match(/(?::[^:])|\\//)) {\n        const termDefined = new Map(defined).set(term, true);\n        const termIri = _expandIri(\n          activeCtx, term, {vocab: true, base: false},\n          localCtx, termDefined, options);\n        if(termIri !== id) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; term in form of IRI must ' +\n            'expand to definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid IRI mapping', context: localCtx});\n        }\n      }\n\n      mapping['@id'] = id;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = (simpleTerm &&\n        !mapping._termHasColon &&\n        id.match(/[:\\/\\?#\\[\\]@]$/));\n    }\n  }\n\n  if(!('@id' in mapping)) {\n    // see if the term has a prefix\n    if(mapping._termHasColon) {\n      const prefix = term.substr(0, colon);\n      if(localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx, localCtx, term: prefix, defined, options\n        });\n      }\n\n      if(activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        const suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if(term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if(!('@vocab' in activeCtx)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @context terms must define an @id.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx, term});\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if(value['@protected'] === true ||\n    (defined.get('@protected') === true && value['@protected'] !== false)) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n\n  if('@type' in value) {\n    let type = value['@type'];\n    if(!_isString(type)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an @context @type value must be a string.',\n        'jsonld.SyntaxError',\n        {code: 'invalid type mapping', context: localCtx});\n    }\n\n    if((type === '@json' || type === '@none')) {\n      if(api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must not be ' +\n          `\"${type}\" in JSON-LD 1.0 mode.`,\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    } else if(type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(\n        activeCtx, type, {vocab: true, base: false}, localCtx, defined,\n        options);\n      if(!_isAbsoluteIri(type)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an ' +\n          'absolute IRI.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n      if(type.indexOf('_:') === 0) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an IRI, ' +\n          'not a blank node identifier.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n\n  if('@container' in value) {\n    // normalize container to an array form\n    const container = _isString(value['@container']) ?\n      [value['@container']] : (value['@container'] || []);\n    const validContainers = ['@list', '@set', '@index', '@language'];\n    let isValid = true;\n    const hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if(api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if(container.includes('@list')) {\n        if(container.length !== 1) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @list must ' +\n            'have no other values',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else if(container.includes('@graph')) {\n        if(container.some(key =>\n          key !== '@graph' && key !== '@id' && key !== '@index' &&\n          key !== '@set')) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @graph must ' +\n            'have no other values other than @id, @index, and @set',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n\n      if(container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id';\n\n        // type mapping must be either @id or @vocab\n        if(!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; container: @type requires @type to be ' +\n            '@id or @vocab.',\n            'jsonld.SyntaxError',\n            {code: 'invalid type mapping', context: localCtx});\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(c => validContainers.includes(c));\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if(!isValid) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value must be ' +\n        'one of the following: ' + validContainers.join(', '),\n        'jsonld.SyntaxError',\n        {code: 'invalid container mapping', context: localCtx});\n    }\n\n    if(mapping.reverse &&\n      !container.every(c => ['@index', '@set'].includes(c))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value for a @reverse ' +\n        'type definition must be @index or @set.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // property indexing\n  if('@index' in value) {\n    if(!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index without @index in @container: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index must expand to an IRI: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    mapping['@index'] = value['@index'];\n  }\n\n  // scoped contexts\n  if('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if('@language' in value && !('@type' in value)) {\n    let language = value['@language'];\n    if(language !== null && !_isString(language)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @language value must be ' +\n        'a string or null.', 'jsonld.SyntaxError',\n        {code: 'invalid language mapping', context: localCtx});\n    }\n\n    // add @language to mapping\n    if(language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if('@prefix' in value) {\n    if(term.match(/:|\\//)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @prefix used on a compact IRI term',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords may not be used as prefixes',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context value for @prefix must be boolean',\n        'jsonld.SyntaxError',\n        {code: 'invalid @prefix value', context: localCtx});\n    }\n  }\n\n  if('@direction' in value) {\n    const direction = value['@direction'];\n    if(direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @direction value must be ' +\n        'null, \"ltr\", or \"rtl\".',\n        'jsonld.SyntaxError',\n        {code: 'invalid base direction', context: localCtx});\n    }\n    mapping['@direction'] = direction;\n  }\n\n  if('@nest' in value) {\n    const nest = value['@nest'];\n    if(!_isString(nest) || (nest !== '@nest' && nest.indexOf('@') === 0)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @nest value must be ' +\n        'a string which is not a keyword other than @nest.',\n        'jsonld.SyntaxError',\n        {code: 'invalid @nest value', context: localCtx});\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  const id = mapping['@id'];\n  if(id === '@context' || id === '@preserve') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',\n      'jsonld.SyntaxError', {code: 'invalid keyword alias', context: localCtx});\n  }\n\n  // Check for overriding protected terms\n  if(previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if(!_deepCompare(previousMapping, mapping)) {\n      const protectedMode = (options && options.protectedMode) || 'error';\n      if(protectedMode === 'error') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; tried to redefine a protected term.',\n          'jsonld.SyntaxError',\n          {code: 'protected term redefinition', context: localCtx, term});\n      } else if(protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {term});\n        return;\n      }\n      throw new JsonLdError(\n        'Invalid protectedMode.',\n        'jsonld.SyntaxError',\n        {code: 'invalid protected mode', context: localCtx, term,\n          protectedMode});\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = (activeCtx, value, relativeTo, options) => {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined,\n    options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if(value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // ignore non-keyword things that look like a keyword\n  if(value.match(KEYWORD_PATTERN)) {\n    return null;\n  }\n\n  // define term dependency if not defined\n  if(localCtx && localCtx.hasOwnProperty(value) &&\n    defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx, localCtx, term: value, defined, options\n    });\n  }\n\n  relativeTo = relativeTo || {};\n  if(relativeTo.vocab) {\n    const mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if(mapping === null) {\n      return null;\n    }\n\n    if(_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  const colon = value.indexOf(':');\n  if(colon > 0) {\n    const prefix = value.substr(0, colon);\n    const suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if(prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if(localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx, localCtx, term: prefix, defined, options\n      });\n    }\n\n    // use mapping if prefix is defined\n    const mapping = activeCtx.mappings.get(prefix);\n    if(mapping && mapping._prefix) {\n      return mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    if(_isAbsoluteIri(value)) {\n      return value;\n    }\n  }\n\n  // prepend vocab\n  if(relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  }\n\n  // prepend base\n  if(relativeTo.base && '@base' in activeCtx) {\n    if(activeCtx['@base']) {\n      // The null case preserves value as potentially relative\n      return prependBase(prependBase(options.base, activeCtx['@base']), value);\n    }\n  } else if(relativeTo.base) {\n    return prependBase(options.base, value);\n  }\n\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = options => {\n  const key = JSON.stringify({processingMode: options.processingMode});\n  const cached = INITIAL_CONTEXT_CACHE.get(key);\n  if(cached) {\n    return cached;\n  }\n\n  const initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if(INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    const activeCtx = this;\n\n    // lazily create inverse\n    if(activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    const inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    const fastCurieMap = activeCtx.fastCurieMap = {};\n    const irisToTerms = {};\n\n    // handle default language\n    const defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase();\n\n    // handle default direction\n    const defaultDirection = activeCtx['@direction'];\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    const mappings = activeCtx.mappings;\n    const terms = [...mappings.keys()].sort(_compareShortestLeast);\n    for(const term of terms) {\n      const mapping = mappings.get(term);\n      if(mapping === null) {\n        continue;\n      }\n\n      let container = mapping['@container'] || '@none';\n      container = [].concat(container).sort().join('');\n\n      if(mapping['@id'] === null) {\n        continue;\n      }\n      // iterate over every IRI in the mapping\n      const ids = _asArray(mapping['@id']);\n      for(const iri of ids) {\n        let entry = inverse[iri];\n        const isKeyword = api.isKeyword(iri);\n\n        if(!entry) {\n          // initialize entry\n          inverse[iri] = entry = {};\n\n          if(!isKeyword && !mapping._termHasColon) {\n            // init IRI to term map and fast CURIE prefixes\n            irisToTerms[iri] = [term];\n            const fastCurieEntry = {iri, terms: irisToTerms[iri]};\n            if(iri[0] in fastCurieMap) {\n              fastCurieMap[iri[0]].push(fastCurieEntry);\n            } else {\n              fastCurieMap[iri[0]] = [fastCurieEntry];\n            }\n          }\n        } else if(!isKeyword && !mapping._termHasColon) {\n          // add IRI to term match\n          irisToTerms[iri].push(term);\n        }\n\n        // add new entry\n        if(!entry[container]) {\n          entry[container] = {\n            '@language': {},\n            '@type': {},\n            '@any': {}\n          };\n        }\n        entry = entry[container];\n        _addPreferredTerm(term, entry['@any'], '@none');\n\n        if(mapping.reverse) {\n          // term is preferred for values using @reverse\n          _addPreferredTerm(term, entry['@type'], '@reverse');\n        } else if(mapping['@type'] === '@none') {\n          _addPreferredTerm(term, entry['@any'], '@none');\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else if('@type' in mapping) {\n          // term is preferred for values using specific type\n          _addPreferredTerm(term, entry['@type'], mapping['@type']);\n        } else if('@language' in mapping && '@direction' in mapping) {\n          // term is preferred for values using specific language and direction\n          const language = mapping['@language'];\n          const direction = mapping['@direction'];\n          if(language && direction) {\n            _addPreferredTerm(term, entry['@language'],\n              `${language}_${direction}`.toLowerCase());\n          } else if(language) {\n            _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n          } else if(direction) {\n            _addPreferredTerm(term, entry['@language'], `_${direction}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@null');\n          }\n        } else if('@language' in mapping) {\n          _addPreferredTerm(term, entry['@language'],\n            (mapping['@language'] || '@null').toLowerCase());\n        } else if('@direction' in mapping) {\n          if(mapping['@direction']) {\n            _addPreferredTerm(term, entry['@language'],\n              `_${mapping['@direction']}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@none');\n          }\n        } else if(defaultDirection) {\n          _addPreferredTerm(term, entry['@language'], `_${defaultDirection}`);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else {\n          // add entries for no type and no language\n          _addPreferredTerm(term, entry['@language'], defaultLanguage);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        }\n      }\n    }\n\n    // build fast CURIE map\n    for(const key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, key, 1);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    const entries = iriMap[key];\n    const next = iriMap[key] = {};\n\n    let iri;\n    let letter;\n    for(const entry of entries) {\n      iri = entry.iri;\n      if(idx >= iri.length) {\n        letter = '';\n      } else {\n        letter = iri[idx];\n      }\n      if(letter in next) {\n        next[letter].push(entry);\n      } else {\n        next[letter] = [entry];\n      }\n    }\n\n    for(const key in next) {\n      if(key === '') {\n        continue;\n      }\n      _buildIriMap(next, key, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if(!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    const child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if(this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertToPreviousContext = this.revertToPreviousContext;\n    if('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n    if('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertToPreviousContext() {\n    if(!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = (ctx, key, type) => {\n  // invalid key\n  if(key === null) {\n    if(type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if(ctx.mappings.has(key)) {\n    const entry = ctx.mappings.get(key);\n\n    if(_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if(entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if(type === '@language' && type in ctx) {\n    return ctx[type];\n  }\n\n  // get default direction\n  if(type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n\n  if(type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = (activeCtx, version) => {\n  if(version.toString() >= '1.1') {\n    return !activeCtx.processingMode ||\n      activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = v => {\n  if(!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n  switch(v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if((!(x1 && typeof x1 === 'object')) ||\n     (!(x2 && typeof x2 === 'object'))) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  const x1Array = Array.isArray(x1);\n  if(x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if(x1Array) {\n    if(x1.length !== x2.length) {\n      return false;\n    }\n    for(let i = 0; i < x1.length; ++i) {\n      if(!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  const k1s = Object.keys(x1);\n  const k2s = Object.keys(x2);\n  if(k1s.length !== k2s.length) {\n    return false;\n  }\n  for(const k1 in x1) {\n    let v1 = x1[k1];\n    let v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if(k1 === '@container') {\n      if(Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if(!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"script"}