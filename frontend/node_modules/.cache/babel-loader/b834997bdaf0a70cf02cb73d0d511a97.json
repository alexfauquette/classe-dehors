{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toArray = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _defineProperty = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _createForOfIteratorHelper = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./graphTypes'),\n    _isList = _require2.isList,\n    _isValue = _require2.isValue,\n    _isGraph = _require2.isGraph,\n    _isSimpleGraph = _require2.isSimpleGraph,\n    _isSubjectReference = _require2.isSubjectReference;\n\nvar _require3 = require('./context'),\n    _expandIri = _require3.expandIri,\n    _getContextValue = _require3.getContextValue,\n    _isKeyword = _require3.isKeyword,\n    _processContext = _require3.process,\n    _processingMode = _require3.processingMode;\n\nvar _require4 = require('./url'),\n    _removeBase = _require4.removeBase,\n    _prependBase = _require4.prependBase;\n\nvar _require5 = require('./util'),\n    _addValue = _require5.addValue,\n    _asArray = _require5.asArray,\n    _compareShortestLeast = _require5.compareShortestLeast;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\n\napi.compact = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$compactionMap, compactionMap, rval, i, compacted, container, ctx, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$compactionMap = _ref.compactionMap, compactionMap = _ref$compactionMap === void 0 ? function () {\n              return undefined;\n            } : _ref$compactionMap;\n\n            if (!_isArray(element)) {\n              _context2.next = 20;\n              break;\n            }\n\n            rval = [];\n            i = 0;\n\n          case 4:\n            if (!(i < element.length)) {\n              _context2.next = 18;\n              break;\n            }\n\n            _context2.next = 7;\n            return api.compact({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: element[i],\n              options: options,\n              compactionMap: compactionMap\n            });\n\n          case 7:\n            compacted = _context2.sent;\n\n            if (!(compacted === null)) {\n              _context2.next = 14;\n              break;\n            }\n\n            _context2.next = 11;\n            return compactionMap({\n              unmappedValue: element[i],\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              parent: element,\n              index: i,\n              options: options\n            });\n\n          case 11:\n            compacted = _context2.sent;\n\n            if (!(compacted === undefined)) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 15);\n\n          case 14:\n            rval.push(compacted);\n\n          case 15:\n            ++i;\n            _context2.next = 4;\n            break;\n\n          case 18:\n            if (options.compactArrays && rval.length === 1) {\n              // use single element if no container is specified\n              container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n              if (container.length === 0) {\n                rval = rval[0];\n              }\n            }\n\n            return _context2.abrupt(\"return\", rval);\n\n          case 20:\n            // use any scoped context on activeProperty\n            ctx = _getContextValue(activeCtx, activeProperty, '@context');\n\n            if (_isUndefined(ctx)) {\n              _context2.next = 25;\n              break;\n            }\n\n            _context2.next = 24;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: ctx,\n              propagate: true,\n              overrideProtected: true,\n              options: options\n            });\n\n          case 24:\n            activeCtx = _context2.sent;\n\n          case 25:\n            if (!_isObject(element)) {\n              _context2.next = 30;\n              break;\n            }\n\n            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var linked, _i, _rval, _container, insideReverse, rval, inputCtx, propertyScopedCtx, types, typeContext, _iterator, _step, type, compactedType, _ctx, keys, _iterator2, _step2, expandedProperty, expandedValue, compactedValue, alias, _compactedValue, _alias, _container2, typeAsSet, isArray, _compactedValue2, compactedProperty, value, _container3, useArray, _alias2, _compactedValue3, _container4, _alias3, _alias4, itemActiveProperty, nestProperty, nestResult, _iterator3, _step3, expandedItem, _itemActiveProperty, _nestProperty, _nestResult, _container5, isGraph, isList, inner, compactedItem, mapObject, key, _mapObject, _key, indexKey, containerKey, others, _asArray2, _asArray3, idKey, typeKey, _types, _asArray4, _asArray5, _isArray2;\n\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(options.link && '@id' in element && options.link.hasOwnProperty(element['@id']))) {\n                        _context.next = 9;\n                        break;\n                      }\n\n                      // check for a linked element to reuse\n                      linked = options.link[element['@id']];\n                      _i = 0;\n\n                    case 3:\n                      if (!(_i < linked.length)) {\n                        _context.next = 9;\n                        break;\n                      }\n\n                      if (!(linked[_i].expanded === element)) {\n                        _context.next = 6;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: linked[_i].compacted\n                      });\n\n                    case 6:\n                      ++_i;\n                      _context.next = 3;\n                      break;\n\n                    case 9:\n                      if (!(_isValue(element) || _isSubjectReference(element))) {\n                        _context.next = 13;\n                        break;\n                      }\n\n                      _rval = api.compactValue({\n                        activeCtx: activeCtx,\n                        activeProperty: activeProperty,\n                        value: element,\n                        options: options\n                      });\n\n                      if (options.link && _isSubjectReference(element)) {\n                        // store linked element\n                        if (!options.link.hasOwnProperty(element['@id'])) {\n                          options.link[element['@id']] = [];\n                        }\n\n                        options.link[element['@id']].push({\n                          expanded: element,\n                          compacted: _rval\n                        });\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: _rval\n                      });\n\n                    case 13:\n                      if (!_isList(element)) {\n                        _context.next = 17;\n                        break;\n                      }\n\n                      _container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n                      if (!_container.includes('@list')) {\n                        _context.next = 17;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: api.compact({\n                          activeCtx: activeCtx,\n                          activeProperty: activeProperty,\n                          element: element['@list'],\n                          options: options,\n                          compactionMap: compactionMap\n                        })\n                      });\n\n                    case 17:\n                      // FIXME: avoid misuse of active property as an expanded property?\n                      insideReverse = activeProperty === '@reverse';\n                      rval = {}; // original context before applying property-scoped and local contexts\n\n                      inputCtx = activeCtx; // revert to previous context, if there is one,\n                      // and element is not a value object or a node reference\n\n                      if (!_isValue(element) && !_isSubjectReference(element)) {\n                        activeCtx = activeCtx.revertToPreviousContext();\n                      } // apply property-scoped context after reverting term-scoped context\n\n\n                      propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n\n                      if (_isUndefined(propertyScopedCtx)) {\n                        _context.next = 26;\n                        break;\n                      }\n\n                      _context.next = 25;\n                      return _processContext({\n                        activeCtx: activeCtx,\n                        localCtx: propertyScopedCtx,\n                        propagate: true,\n                        overrideProtected: true,\n                        options: options\n                      });\n\n                    case 25:\n                      activeCtx = _context.sent;\n\n                    case 26:\n                      if (options.link && '@id' in element) {\n                        // store linked element\n                        if (!options.link.hasOwnProperty(element['@id'])) {\n                          options.link[element['@id']] = [];\n                        }\n\n                        options.link[element['@id']].push({\n                          expanded: element,\n                          compacted: rval\n                        });\n                      } // apply any context defined on an alias of @type\n                      // if key is @type and any compacted value is a term having a local\n                      // context, overlay that context\n\n\n                      types = element['@type'] || [];\n\n                      if (types.length > 1) {\n                        types = Array.from(types).sort();\n                      } // find all type-scoped contexts based on current context, prior to\n                      // updating it\n\n\n                      typeContext = activeCtx;\n                      _iterator = _createForOfIteratorHelper(types);\n                      _context.prev = 31;\n\n                      _iterator.s();\n\n                    case 33:\n                      if ((_step = _iterator.n()).done) {\n                        _context.next = 43;\n                        break;\n                      }\n\n                      type = _step.value;\n                      compactedType = api.compactIri({\n                        activeCtx: typeContext,\n                        iri: type,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      }); // Use any type-scoped context defined on this value\n\n                      _ctx = _getContextValue(inputCtx, compactedType, '@context');\n\n                      if (_isUndefined(_ctx)) {\n                        _context.next = 41;\n                        break;\n                      }\n\n                      _context.next = 40;\n                      return _processContext({\n                        activeCtx: activeCtx,\n                        localCtx: _ctx,\n                        options: options,\n                        propagate: false\n                      });\n\n                    case 40:\n                      activeCtx = _context.sent;\n\n                    case 41:\n                      _context.next = 33;\n                      break;\n\n                    case 43:\n                      _context.next = 48;\n                      break;\n\n                    case 45:\n                      _context.prev = 45;\n                      _context.t0 = _context[\"catch\"](31);\n\n                      _iterator.e(_context.t0);\n\n                    case 48:\n                      _context.prev = 48;\n\n                      _iterator.f();\n\n                      return _context.finish(48);\n\n                    case 51:\n                      // process element keys in order\n                      keys = Object.keys(element).sort();\n                      _iterator2 = _createForOfIteratorHelper(keys);\n                      _context.prev = 53;\n\n                      _iterator2.s();\n\n                    case 55:\n                      if ((_step2 = _iterator2.n()).done) {\n                        _context.next = 211;\n                        break;\n                      }\n\n                      expandedProperty = _step2.value;\n                      expandedValue = element[expandedProperty]; // compact @id\n\n                      if (!(expandedProperty === '@id')) {\n                        _context.next = 64;\n                        break;\n                      }\n\n                      compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n                        return api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: expandedIri,\n                          relativeTo: {\n                            vocab: false\n                          },\n                          base: options.base\n                        });\n                      });\n\n                      if (compactedValue.length === 1) {\n                        compactedValue = compactedValue[0];\n                      } // use keyword alias and add value\n\n\n                      alias = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@id',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n                      rval[alias] = compactedValue;\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 64:\n                      if (!(expandedProperty === '@type')) {\n                        _context.next = 73;\n                        break;\n                      }\n\n                      // resolve type values against previous context\n                      _compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n                        return api.compactIri({\n                          activeCtx: inputCtx,\n                          iri: expandedIri,\n                          relativeTo: {\n                            vocab: true\n                          }\n                        });\n                      });\n\n                      if (_compactedValue.length === 1) {\n                        _compactedValue = _compactedValue[0];\n                      } // use keyword alias and add value\n\n\n                      _alias = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@type',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n                      _container2 = _getContextValue(activeCtx, _alias, '@container') || []; // treat as array for @type if @container includes @set\n\n                      typeAsSet = _container2.includes('@set') && _processingMode(activeCtx, 1.1);\n                      isArray = typeAsSet || _isArray(_compactedValue) && expandedValue.length === 0;\n\n                      _addValue(rval, _alias, _compactedValue, {\n                        propertyIsArray: isArray\n                      });\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 73:\n                      if (!(expandedProperty === '@reverse')) {\n                        _context.next = 80;\n                        break;\n                      }\n\n                      _context.next = 76;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: '@reverse',\n                        element: expandedValue,\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 76:\n                      _compactedValue2 = _context.sent;\n\n                      // handle double-reversed properties\n                      for (compactedProperty in _compactedValue2) {\n                        if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n                          value = _compactedValue2[compactedProperty];\n                          _container3 = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n                          useArray = _container3.includes('@set') || !options.compactArrays;\n\n                          _addValue(rval, compactedProperty, value, {\n                            propertyIsArray: useArray\n                          });\n\n                          delete _compactedValue2[compactedProperty];\n                        }\n                      }\n\n                      if (Object.keys(_compactedValue2).length > 0) {\n                        // use keyword alias and add value\n                        _alias2 = api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: expandedProperty,\n                          relativeTo: {\n                            vocab: true\n                          }\n                        });\n\n                        _addValue(rval, _alias2, _compactedValue2);\n                      }\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 80:\n                      if (!(expandedProperty === '@preserve')) {\n                        _context.next = 86;\n                        break;\n                      }\n\n                      _context.next = 83;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: activeProperty,\n                        element: expandedValue,\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 83:\n                      _compactedValue3 = _context.sent;\n\n                      if (!(_isArray(_compactedValue3) && _compactedValue3.length === 0)) {\n                        _addValue(rval, expandedProperty, _compactedValue3);\n                      }\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 86:\n                      if (!(expandedProperty === '@index')) {\n                        _context.next = 93;\n                        break;\n                      }\n\n                      // drop @index if inside an @index container\n                      _container4 = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n                      if (!_container4.includes('@index')) {\n                        _context.next = 90;\n                        break;\n                      }\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 90:\n                      // use keyword alias and add value\n                      _alias3 = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: expandedProperty,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n\n                      _addValue(rval, _alias3, expandedValue);\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 93:\n                      if (!(expandedProperty !== '@graph' && expandedProperty !== '@list' && expandedProperty !== '@included' && _isKeyword(expandedProperty))) {\n                        _context.next = 97;\n                        break;\n                      }\n\n                      // use keyword alias and add value as is\n                      _alias4 = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: expandedProperty,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n\n                      _addValue(rval, _alias4, expandedValue);\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 97:\n                      if (_isArray(expandedValue)) {\n                        _context.next = 99;\n                        break;\n                      }\n\n                      throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n\n                    case 99:\n                      // preserve empty arrays\n                      if (expandedValue.length === 0) {\n                        itemActiveProperty = api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: expandedProperty,\n                          value: expandedValue,\n                          relativeTo: {\n                            vocab: true\n                          },\n                          reverse: insideReverse\n                        });\n                        nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n                        nestResult = rval;\n\n                        if (nestProperty) {\n                          _checkNestProperty(activeCtx, nestProperty, options);\n\n                          if (!_isObject(rval[nestProperty])) {\n                            rval[nestProperty] = {};\n                          }\n\n                          nestResult = rval[nestProperty];\n                        }\n\n                        _addValue(nestResult, itemActiveProperty, expandedValue, {\n                          propertyIsArray: true\n                        });\n                      } // recusively process array values\n\n\n                      _iterator3 = _createForOfIteratorHelper(expandedValue);\n                      _context.prev = 101;\n\n                      _iterator3.s();\n\n                    case 103:\n                      if ((_step3 = _iterator3.n()).done) {\n                        _context.next = 201;\n                        break;\n                      }\n\n                      expandedItem = _step3.value;\n                      // compact property and get container type\n                      _itemActiveProperty = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: expandedProperty,\n                        value: expandedItem,\n                        relativeTo: {\n                          vocab: true\n                        },\n                        reverse: insideReverse\n                      }); // if itemActiveProperty is a @nest property, add values to nestResult,\n                      // otherwise rval\n\n                      _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;\n                      _nestResult = rval;\n\n                      if (_nestProperty) {\n                        _checkNestProperty(activeCtx, _nestProperty, options);\n\n                        if (!_isObject(rval[_nestProperty])) {\n                          rval[_nestProperty] = {};\n                        }\n\n                        _nestResult = rval[_nestProperty];\n                      }\n\n                      _container5 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n\n                      isGraph = _isGraph(expandedItem);\n                      isList = _isList(expandedItem);\n                      inner = void 0;\n\n                      if (isList) {\n                        inner = expandedItem['@list'];\n                      } else if (isGraph) {\n                        inner = expandedItem['@graph'];\n                      } // recursively compact expanded item\n\n\n                      _context.next = 116;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: _itemActiveProperty,\n                        element: isList || isGraph ? inner : expandedItem,\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 116:\n                      compactedItem = _context.sent;\n\n                      if (!isList) {\n                        _context.next = 126;\n                        break;\n                      }\n\n                      // ensure @list value is an array\n                      if (!_isArray(compactedItem)) {\n                        compactedItem = [compactedItem];\n                      }\n\n                      if (_container5.includes('@list')) {\n                        _context.next = 124;\n                        break;\n                      }\n\n                      // wrap using @list alias\n                      compactedItem = _defineProperty({}, api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@list',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      }), compactedItem); // include @index from expanded @list, if any\n\n                      if ('@index' in expandedItem) {\n                        compactedItem[api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@index',\n                          relativeTo: {\n                            vocab: true\n                          }\n                        })] = expandedItem['@index'];\n                      }\n\n                      _context.next = 126;\n                      break;\n\n                    case 124:\n                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                        valueIsArray: true,\n                        allowDuplicate: true\n                      });\n\n                      return _context.abrupt(\"continue\", 199);\n\n                    case 126:\n                      if (!isGraph) {\n                        _context.next = 130;\n                        break;\n                      }\n\n                      if (_container5.includes('@graph') && (_container5.includes('@id') || _container5.includes('@index') && _isSimpleGraph(expandedItem))) {\n                        // get or create the map object\n                        mapObject = void 0;\n\n                        if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                          mapObject = _nestResult[_itemActiveProperty];\n                        } else {\n                          _nestResult[_itemActiveProperty] = mapObject = {};\n                        } // index on @id or @index or alias of @none\n\n\n                        key = (_container5.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@none',\n                          relativeTo: {\n                            vocab: true\n                          }\n                        }); // add compactedItem to map, using value of `@id` or a new blank\n                        // node identifier\n\n                        _addValue(mapObject, key, compactedItem, {\n                          propertyIsArray: !options.compactArrays || _container5.includes('@set')\n                        });\n                      } else if (_container5.includes('@graph') && _isSimpleGraph(expandedItem)) {\n                        // container includes @graph but not @id or @index and value is a\n                        // simple graph object add compact value\n                        // if compactedItem contains multiple values, it is wrapped in\n                        // `@included`\n                        if (_isArray(compactedItem) && compactedItem.length > 1) {\n                          compactedItem = {\n                            '@included': compactedItem\n                          };\n                        }\n\n                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                          propertyIsArray: !options.compactArrays || _container5.includes('@set')\n                        });\n                      } else {\n                        // wrap using @graph alias, remove array if only one item and\n                        // compactArrays not set\n                        if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n                          compactedItem = compactedItem[0];\n                        }\n\n                        compactedItem = _defineProperty({}, api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@graph',\n                          relativeTo: {\n                            vocab: true\n                          }\n                        }), compactedItem); // include @id from expanded graph, if any\n\n                        if ('@id' in expandedItem) {\n                          compactedItem[api.compactIri({\n                            activeCtx: activeCtx,\n                            iri: '@id',\n                            relativeTo: {\n                              vocab: true\n                            }\n                          })] = expandedItem['@id'];\n                        } // include @index from expanded graph, if any\n\n\n                        if ('@index' in expandedItem) {\n                          compactedItem[api.compactIri({\n                            activeCtx: activeCtx,\n                            iri: '@index',\n                            relativeTo: {\n                              vocab: true\n                            }\n                          })] = expandedItem['@index'];\n                        }\n\n                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                          propertyIsArray: !options.compactArrays || _container5.includes('@set')\n                        });\n                      }\n\n                      _context.next = 199;\n                      break;\n\n                    case 130:\n                      if (!(_container5.includes('@language') || _container5.includes('@index') || _container5.includes('@id') || _container5.includes('@type'))) {\n                        _context.next = 197;\n                        break;\n                      }\n\n                      // handle language and index maps\n                      // get or create the map object\n                      _mapObject = void 0;\n\n                      if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                        _mapObject = _nestResult[_itemActiveProperty];\n                      } else {\n                        _nestResult[_itemActiveProperty] = _mapObject = {};\n                      }\n\n                      _key = void 0;\n\n                      if (!_container5.includes('@language')) {\n                        _context.next = 139;\n                        break;\n                      }\n\n                      // if container is a language map, simplify compacted value to\n                      // a simple string\n                      if (_isValue(compactedItem)) {\n                        compactedItem = compactedItem['@value'];\n                      }\n\n                      _key = expandedItem['@language'];\n                      _context.next = 193;\n                      break;\n\n                    case 139:\n                      if (!_container5.includes('@index')) {\n                        _context.next = 167;\n                        break;\n                      }\n\n                      indexKey = _getContextValue(activeCtx, _itemActiveProperty, '@index') || '@index';\n                      containerKey = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: indexKey,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n\n                      if (!(indexKey === '@index')) {\n                        _context.next = 147;\n                        break;\n                      }\n\n                      _key = expandedItem['@index'];\n                      delete compactedItem[containerKey];\n                      _context.next = 165;\n                      break;\n\n                    case 147:\n                      others = void 0;\n                      _asArray2 = _asArray(compactedItem[indexKey] || []);\n                      _asArray3 = _toArray(_asArray2);\n                      _key = _asArray3[0];\n                      others = _asArray3.slice(1);\n\n                      if (_isString(_key)) {\n                        _context.next = 156;\n                        break;\n                      }\n\n                      // Will use @none if it isn't a string.\n                      _key = null;\n                      _context.next = 165;\n                      break;\n\n                    case 156:\n                      _context.t1 = others.length;\n                      _context.next = _context.t1 === 0 ? 159 : _context.t1 === 1 ? 161 : 163;\n                      break;\n\n                    case 159:\n                      delete compactedItem[indexKey];\n                      return _context.abrupt(\"break\", 165);\n\n                    case 161:\n                      compactedItem[indexKey] = others[0];\n                      return _context.abrupt(\"break\", 165);\n\n                    case 163:\n                      compactedItem[indexKey] = others;\n                      return _context.abrupt(\"break\", 165);\n\n                    case 165:\n                      _context.next = 193;\n                      break;\n\n                    case 167:\n                      if (!_container5.includes('@id')) {\n                        _context.next = 173;\n                        break;\n                      }\n\n                      idKey = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@id',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n                      _key = compactedItem[idKey];\n                      delete compactedItem[idKey];\n                      _context.next = 193;\n                      break;\n\n                    case 173:\n                      if (!_container5.includes('@type')) {\n                        _context.next = 193;\n                        break;\n                      }\n\n                      typeKey = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@type',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n                      _types = void 0;\n                      _asArray4 = _asArray(compactedItem[typeKey] || []);\n                      _asArray5 = _toArray(_asArray4);\n                      _key = _asArray5[0];\n                      _types = _asArray5.slice(1);\n                      _context.t2 = _types.length;\n                      _context.next = _context.t2 === 0 ? 183 : _context.t2 === 1 ? 185 : 187;\n                      break;\n\n                    case 183:\n                      delete compactedItem[typeKey];\n                      return _context.abrupt(\"break\", 189);\n\n                    case 185:\n                      compactedItem[typeKey] = _types[0];\n                      return _context.abrupt(\"break\", 189);\n\n                    case 187:\n                      compactedItem[typeKey] = _types;\n                      return _context.abrupt(\"break\", 189);\n\n                    case 189:\n                      if (!(Object.keys(compactedItem).length === 1 && '@id' in expandedItem)) {\n                        _context.next = 193;\n                        break;\n                      }\n\n                      _context.next = 192;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: _itemActiveProperty,\n                        element: {\n                          '@id': expandedItem['@id']\n                        },\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 192:\n                      compactedItem = _context.sent;\n\n                    case 193:\n                      // if compacting this value which has no key, index on @none\n                      if (!_key) {\n                        _key = api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@none',\n                          relativeTo: {\n                            vocab: true\n                          }\n                        });\n                      } // add compact value to map object using key from expanded value\n                      // based on the container type\n\n\n                      _addValue(_mapObject, _key, compactedItem, {\n                        propertyIsArray: _container5.includes('@set')\n                      });\n\n                      _context.next = 199;\n                      break;\n\n                    case 197:\n                      // use an array if: compactArrays flag is false,\n                      // @container is @set or @list , value is an empty\n                      // array, or key is @graph\n                      _isArray2 = !options.compactArrays || _container5.includes('@set') || _container5.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n\n                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                        propertyIsArray: _isArray2\n                      });\n\n                    case 199:\n                      _context.next = 103;\n                      break;\n\n                    case 201:\n                      _context.next = 206;\n                      break;\n\n                    case 203:\n                      _context.prev = 203;\n                      _context.t3 = _context[\"catch\"](101);\n\n                      _iterator3.e(_context.t3);\n\n                    case 206:\n                      _context.prev = 206;\n\n                      _iterator3.f();\n\n                      return _context.finish(206);\n\n                    case 209:\n                      _context.next = 55;\n                      break;\n\n                    case 211:\n                      _context.next = 216;\n                      break;\n\n                    case 213:\n                      _context.prev = 213;\n                      _context.t4 = _context[\"catch\"](53);\n\n                      _iterator2.e(_context.t4);\n\n                    case 216:\n                      _context.prev = 216;\n\n                      _iterator2.f();\n\n                      return _context.finish(216);\n\n                    case 219:\n                      return _context.abrupt(\"return\", {\n                        v: rval\n                      });\n\n                    case 220:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, null, [[31, 45, 48, 51], [53, 213, 216, 219], [101, 203, 206, 209]]);\n            })(), \"t0\", 27);\n\n          case 27:\n            _ret = _context2.t0;\n\n            if (!(typeof _ret === \"object\")) {\n              _context2.next = 30;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _ret.v);\n\n          case 30:\n            return _context2.abrupt(\"return\", element);\n\n          case 31:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\n\n\napi.compactIri = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n      iri = _ref3.iri,\n      _ref3$value = _ref3.value,\n      value = _ref3$value === void 0 ? null : _ref3$value,\n      _ref3$relativeTo = _ref3.relativeTo,\n      relativeTo = _ref3$relativeTo === void 0 ? {\n    vocab: false\n  } : _ref3$relativeTo,\n      _ref3$reverse = _ref3.reverse,\n      reverse = _ref3$reverse === void 0 ? false : _ref3$reverse,\n      _ref3$base = _ref3.base,\n      base = _ref3$base === void 0 ? null : _ref3$base;\n\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  var inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias\n\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  } // use inverse context to pick a term if iri is relative to vocab\n\n\n  if (relativeTo.vocab && iri in inverseCtx) {\n    var defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value\n\n    var containers = [];\n\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    } // if value is a preserve object, use its value\n\n\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    } // prefer most specific container including @graph, prefering @set\n    // variations\n\n\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // favor idmap if the graph is has an @id\n\n\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n\n      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed\n\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // allow idmap if the graph does not have an @id\n\n\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    } // defaults for term selection based on type/language\n\n\n    var typeOrLanguage = '@language';\n    var typeOrLanguageValue = '@null';\n\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n\n      var list = value['@list'];\n\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        var commonLanguage = list.length === 0 ? defaultLanguage : null;\n        var commonType = null;\n\n        for (var i = 0; i < list.length; ++i) {\n          var item = list[i];\n          var itemLanguage = '@none';\n          var itemType = '@none';\n\n          if (_isValue(item)) {\n            if ('@direction' in item) {\n              var lang = (item['@language'] || '').toLowerCase();\n              var dir = item['@direction'];\n              itemLanguage = \"\".concat(lang, \"_\").concat(dir);\n            } else if ('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          } // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n\n\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          var _dir = value['@direction'];\n\n          if (_dir) {\n            typeOrLanguageValue = \"\".concat(typeOrLanguageValue, \"_\").concat(_dir);\n          }\n        } else if ('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = \"_\".concat(value['@direction']);\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n\n      containers.push('@set');\n    } // do term selection\n\n\n    containers.push('@none'); // an index map can be used to index values using @none, so add as a low\n    // priority\n\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    } // values without type or language can use @language map\n\n\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n\n    if (term !== null) {\n      return term;\n    }\n  } // no term match, use @vocab if available\n\n\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      var vocab = activeCtx['@vocab'];\n\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        var suffix = iri.substr(vocab.length);\n\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  } // no term or @vocab match, check for possible CURIEs\n\n\n  var choice = null; // TODO: make FastCurieMap a class with a method to do this lookup\n\n  var partialMatches = [];\n  var iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n\n  var maxPartialLength = iri.length - 1;\n\n  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {\n    iriMap = iriMap[iri[_i2]];\n\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  } // check partial matches in reverse order to prefer longest ones first\n\n\n  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {\n    var entry = partialMatches[_i3];\n    var terms = entry.terms;\n\n    var _iterator4 = _createForOfIteratorHelper(terms),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _term = _step4.value;\n        // a CURIE is usable if:\n        // 1. it has no mapping, OR\n        // 2. value is null, which means we're not compacting an @value, AND\n        //   the mapping matches the IRI\n        var curie = _term + ':' + iri.substr(entry.iri.length);\n        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically\n        // less than the current choice\n\n        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n          choice = curie;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } // return chosen curie\n\n\n  if (choice !== null) {\n    return choice;\n  } // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n\n\n  var _iterator5 = _createForOfIteratorHelper(activeCtx.mappings),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _step5$value = _slicedToArray(_step5.value, 2),\n          _term2 = _step5$value[0],\n          td = _step5$value[1];\n\n      if (td && td._prefix && iri.startsWith(_term2 + ':')) {\n        throw new JsonLdError(\"Absolute IRI \\\"\".concat(iri, \"\\\" confused with prefix \\\"\").concat(_term2, \"\\\".\"), 'jsonld.SyntaxError', {\n          code: 'IRI confused with prefix',\n          context: activeCtx\n        });\n      }\n    } // compact IRI relative to base\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  if (!relativeTo.vocab) {\n    if ('@base' in activeCtx) {\n      if (!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  } // return IRI as is\n\n\n  return iri;\n};\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\n\n\napi.compactValue = function (_ref4) {\n  var activeCtx = _ref4.activeCtx,\n      activeProperty = _ref4.activeProperty,\n      value = _ref4.value,\n      options = _ref4.options;\n\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    var _type = _getContextValue(activeCtx, activeProperty, '@type');\n\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    var direction = _getContextValue(activeCtx, activeProperty, '@direction');\n\n    var container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved\n\n    var preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...\n\n    if (!preserveIndex && _type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === _type) {\n        return value['@value'];\n      }\n\n      if ('@language' in value && value['@language'] === language && '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n\n      if ('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n\n      if ('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    } // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n\n\n    var keyCount = Object.keys(value).length;\n    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    var hasDefaultLanguage = ('@language' in activeCtx);\n\n    var isValueString = _isString(value['@value']);\n\n    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n\n    if (isValueOnlyKey && _type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    var rval = {}; // preserve @index\n\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx: activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    }\n\n    if ('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@direction',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@direction'];\n    } // alias @value\n\n\n    rval[api.compactIri({\n      activeCtx: activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  } // value is a subject reference\n\n\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  var type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  var compacted = api.compactIri({\n    activeCtx: activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    },\n    base: options.base\n  }); // compact to scalar\n\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return _defineProperty({}, api.compactIri({\n    activeCtx: activeCtx,\n    iri: '@id',\n    relativeTo: {\n      vocab: true\n    }\n  }), compacted);\n};\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\n\n\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  } // preferences for the value of @type or @language\n\n\n  var prefs = []; // determine prefs for @id based on whether or not value compacts to a term\n\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    } // try to compact value to a term\n\n\n    var term = api.compactIri({\n      activeCtx: activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue); // consider direction only\n\n    var langDir = prefs.find(function (el) {\n      return el.includes('_');\n    });\n\n    if (langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n\n  prefs.push('@none');\n  var containerMap = activeCtx.inverse[iri];\n\n  var _iterator6 = _createForOfIteratorHelper(containers),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var container = _step6.value;\n\n      // if container not available in the map, continue\n      if (!(container in containerMap)) {\n        continue;\n      }\n\n      var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n\n      var _iterator7 = _createForOfIteratorHelper(prefs),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var pref = _step7.value;\n\n          // if type/language option not available in the map, continue\n          if (!(pref in typeOrLanguageValueMap)) {\n            continue;\n          } // select term\n\n\n          return typeOrLanguageValueMap[pref];\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return null;\n}\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\n\n\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"sources":["/home/alexandre/dev/classe-dehors/frontend/node_modules/jsonld/lib/compact.js"],"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_isSimpleGraph","isSimpleGraph","_isSubjectReference","isSubjectReference","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_processingMode","processingMode","_removeBase","removeBase","_prependBase","prependBase","_addValue","addValue","_asArray","asArray","_compareShortestLeast","compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","base","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","lang","toLowerCase","dir","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","direction","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","prefs","apply","langDir","find","el","replace","containerMap","inverse","typeOrLanguageValueMap","pref"],"mappings":"AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAA3B;;eAOIA,OAAO,CAAC,SAAD,C;IAJAC,Q,YAATC,O;IACUC,S,YAAVC,Q;IACUC,S,YAAVC,Q;IACaC,Y,YAAbC,W;;gBASER,OAAO,CAAC,cAAD,C;IALDS,O,aAARC,M;IACSC,Q,aAATC,O;IACSC,Q,aAATC,O;IACeC,c,aAAfC,a;IACoBC,mB,aAApBC,kB;;gBASElB,OAAO,CAAC,WAAD,C;IALEmB,U,aAAXC,S;IACiBC,gB,aAAjBC,e;IACWC,U,aAAXC,S;IACSC,e,aAATC,O;IACgBC,e,aAAhBC,c;;gBAME5B,OAAO,CAAC,OAAD,C;IAFG6B,W,aAAZC,U;IACaC,Y,aAAbC,W;;gBAOEhC,OAAO,CAAC,QAAD,C;IAHCiC,S,aAAVC,Q;IACSC,Q,aAATC,O;IACsBC,qB,aAAtBC,oB;;AAGF,IAAMC,GAAG,GAAG,EAAZ;AACAC,MAAM,CAACC,OAAP,GAAiBF,GAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,GAAG,CAACG,OAAJ;AAAA,uEAAc;AAAA;;AAAA;AAAA;AAAA;AAAA;AACZC,YAAAA,SADY,QACZA,SADY,6BAEZC,cAFY,EAEZA,cAFY,oCAEK,IAFL,wBAGZC,OAHY,QAGZA,OAHY,sBAIZC,OAJY,EAIZA,OAJY,6BAIF,EAJE,2CAKZC,aALY,EAKZA,aALY,mCAKI;AAAA,qBAAMC,SAAN;AAAA,aALJ;;AAAA,iBAQT/C,QAAQ,CAAC4C,OAAD,CARC;AAAA;AAAA;AAAA;;AASNI,YAAAA,IATM,GASC,EATD;AAUFC,YAAAA,CAVE,GAUE,CAVF;;AAAA;AAAA,kBAUKA,CAAC,GAAGL,OAAO,CAACM,MAVjB;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAYcZ,GAAG,CAACG,OAAJ,CAAY;AAChCC,cAAAA,SAAS,EAATA,SADgC;AAEhCC,cAAAA,cAAc,EAAdA,cAFgC;AAGhCC,cAAAA,OAAO,EAAEA,OAAO,CAACK,CAAD,CAHgB;AAIhCJ,cAAAA,OAAO,EAAPA,OAJgC;AAKhCC,cAAAA,aAAa,EAAbA;AALgC,aAAZ,CAZd;;AAAA;AAYJK,YAAAA,SAZI;;AAAA,kBAmBLA,SAAS,KAAK,IAnBT;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAoBYL,aAAa,CAAC;AAC9BM,cAAAA,aAAa,EAAER,OAAO,CAACK,CAAD,CADQ;AAE9BP,cAAAA,SAAS,EAATA,SAF8B;AAG9BC,cAAAA,cAAc,EAAdA,cAH8B;AAI9BU,cAAAA,MAAM,EAAET,OAJsB;AAK9BU,cAAAA,KAAK,EAAEL,CALuB;AAM9BJ,cAAAA,OAAO,EAAPA;AAN8B,aAAD,CApBzB;;AAAA;AAoBNM,YAAAA,SApBM;;AAAA,kBA4BHA,SAAS,KAAKJ,SA5BX;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAgCRC,YAAAA,IAAI,CAACO,IAAL,CAAUJ,SAAV;;AAhCQ;AAUyB,cAAEF,CAV3B;AAAA;AAAA;;AAAA;AAkCV,gBAAGJ,OAAO,CAACW,aAAR,IAAyBR,IAAI,CAACE,MAAL,KAAgB,CAA5C,EAA+C;AAC7C;AACMO,cAAAA,SAFuC,GAE3BrC,gBAAgB,CAChCsB,SADgC,EACrBC,cADqB,EACL,YADK,CAAhB,IAC4B,EAHD;;AAI7C,kBAAGc,SAAS,CAACP,MAAV,KAAqB,CAAxB,EAA2B;AACzBF,gBAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAX;AACD;AACF;;AAzCS,8CA0CHA,IA1CG;;AAAA;AA6CZ;AACMU,YAAAA,GA9CM,GA8CAtC,gBAAgB,CAACsB,SAAD,EAAYC,cAAZ,EAA4B,UAA5B,CA9ChB;;AAAA,gBA+CRrC,YAAY,CAACoD,GAAD,CA/CJ;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAgDQlC,eAAe,CAAC;AAChCkB,cAAAA,SAAS,EAATA,SADgC;AAEhCiB,cAAAA,QAAQ,EAAED,GAFsB;AAGhCE,cAAAA,SAAS,EAAE,IAHqB;AAIhCC,cAAAA,iBAAiB,EAAE,IAJa;AAKhChB,cAAAA,OAAO,EAAPA;AALgC,aAAD,CAhDvB;;AAAA;AAgDVH,YAAAA,SAhDU;;AAAA;AAAA,iBA0DTxC,SAAS,CAAC0C,OAAD,CA1DA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,4BA2DPC,OAAO,CAACiB,IAAR,IAAgB,SAASlB,OAAzB,IACDC,OAAO,CAACiB,IAAR,CAAaC,cAAb,CAA4BnB,OAAO,CAAC,KAAD,CAAnC,CA5DQ;AAAA;AAAA;AAAA;;AA6DR;AACMoB,sBAAAA,MA9DE,GA8DOnB,OAAO,CAACiB,IAAR,CAAalB,OAAO,CAAC,KAAD,CAApB,CA9DP;AA+DAK,sBAAAA,EA/DA,GA+DI,CA/DJ;;AAAA;AAAA,4BA+DOA,EAAC,GAAGe,MAAM,CAACd,MA/DlB;AAAA;AAAA;AAAA;;AAAA,4BAgEHc,MAAM,CAACf,EAAD,CAAN,CAAUgB,QAAV,KAAuBrB,OAhEpB;AAAA;AAAA;AAAA;;AAAA;AAAA,2BAiEGoB,MAAM,CAACf,EAAD,CAAN,CAAUE;AAjEb;;AAAA;AA+D0B,wBAAEF,EA/D5B;AAAA;AAAA;;AAAA;AAAA,4BAuEPvC,QAAQ,CAACkC,OAAD,CAAR,IAAqB5B,mBAAmB,CAAC4B,OAAD,CAvEjC;AAAA;AAAA;AAAA;;AAwEFI,sBAAAA,KAxEE,GAyENV,GAAG,CAAC4B,YAAJ,CAAiB;AAACxB,wBAAAA,SAAS,EAATA,SAAD;AAAYC,wBAAAA,cAAc,EAAdA,cAAZ;AAA4BwB,wBAAAA,KAAK,EAAEvB,OAAnC;AAA4CC,wBAAAA,OAAO,EAAPA;AAA5C,uBAAjB,CAzEM;;AA0ER,0BAAGA,OAAO,CAACiB,IAAR,IAAgB9C,mBAAmB,CAAC4B,OAAD,CAAtC,EAAiD;AAC/C;AACA,4BAAG,CAAEC,OAAO,CAACiB,IAAR,CAAaC,cAAb,CAA4BnB,OAAO,CAAC,KAAD,CAAnC,CAAL,EAAmD;AACjDC,0BAAAA,OAAO,CAACiB,IAAR,CAAalB,OAAO,CAAC,KAAD,CAApB,IAA+B,EAA/B;AACD;;AACDC,wBAAAA,OAAO,CAACiB,IAAR,CAAalB,OAAO,CAAC,KAAD,CAApB,EAA6BW,IAA7B,CAAkC;AAACU,0BAAAA,QAAQ,EAAErB,OAAX;AAAoBO,0BAAAA,SAAS,EAAEH;AAA/B,yBAAlC;AACD;;AAhFO;AAAA,2BAiFDA;AAjFC;;AAAA;AAAA,2BAsFPxC,OAAO,CAACoC,OAAD,CAtFA;AAAA;AAAA;AAAA;;AAuFFa,sBAAAA,UAvFE,GAuFUrC,gBAAgB,CAChCsB,SADgC,EACrBC,cADqB,EACL,YADK,CAAhB,IAC4B,EAxFtC;;AAAA,2BAyFLc,UAAS,CAACW,QAAV,CAAmB,OAAnB,CAzFK;AAAA;AAAA;AAAA;;AAAA;AAAA,2BA0FC9B,GAAG,CAACG,OAAJ,CAAY;AACjBC,0BAAAA,SAAS,EAATA,SADiB;AAEjBC,0BAAAA,cAAc,EAAdA,cAFiB;AAGjBC,0BAAAA,OAAO,EAAEA,OAAO,CAAC,OAAD,CAHC;AAIjBC,0BAAAA,OAAO,EAAPA,OAJiB;AAKjBC,0BAAAA,aAAa,EAAbA;AALiB,yBAAZ;AA1FD;;AAAA;AAoGV;AACMuB,sBAAAA,aArGI,GAqGa1B,cAAc,KAAK,UArGhC;AAuGJK,sBAAAA,IAvGI,GAuGG,EAvGH,EAyGV;;AACMsB,sBAAAA,QA1GI,GA0GO5B,SA1GP,EA4GV;AACA;;AACA,0BAAG,CAAChC,QAAQ,CAACkC,OAAD,CAAT,IAAsB,CAAC5B,mBAAmB,CAAC4B,OAAD,CAA7C,EAAwD;AACtDF,wBAAAA,SAAS,GAAGA,SAAS,CAAC6B,uBAAV,EAAZ;AACD,uBAhHS,CAkHV;;;AACMC,sBAAAA,iBAnHI,GAoHRpD,gBAAgB,CAACkD,QAAD,EAAW3B,cAAX,EAA2B,UAA3B,CApHR;;AAAA,0BAqHNrC,YAAY,CAACkE,iBAAD,CArHN;AAAA;AAAA;AAAA;;AAAA;AAAA,6BAsHUhD,eAAe,CAAC;AAChCkB,wBAAAA,SAAS,EAATA,SADgC;AAEhCiB,wBAAAA,QAAQ,EAAEa,iBAFsB;AAGhCZ,wBAAAA,SAAS,EAAE,IAHqB;AAIhCC,wBAAAA,iBAAiB,EAAE,IAJa;AAKhChB,wBAAAA,OAAO,EAAPA;AALgC,uBAAD,CAtHzB;;AAAA;AAsHRH,sBAAAA,SAtHQ;;AAAA;AA+HV,0BAAGG,OAAO,CAACiB,IAAR,IAAgB,SAASlB,OAA5B,EAAqC;AACnC;AACA,4BAAG,CAACC,OAAO,CAACiB,IAAR,CAAaC,cAAb,CAA4BnB,OAAO,CAAC,KAAD,CAAnC,CAAJ,EAAiD;AAC/CC,0BAAAA,OAAO,CAACiB,IAAR,CAAalB,OAAO,CAAC,KAAD,CAApB,IAA+B,EAA/B;AACD;;AACDC,wBAAAA,OAAO,CAACiB,IAAR,CAAalB,OAAO,CAAC,KAAD,CAApB,EAA6BW,IAA7B,CAAkC;AAACU,0BAAAA,QAAQ,EAAErB,OAAX;AAAoBO,0BAAAA,SAAS,EAAEH;AAA/B,yBAAlC;AACD,uBArIS,CAuIV;AACA;AACA;;;AACIyB,sBAAAA,KA1IM,GA0IE7B,OAAO,CAAC,OAAD,CAAP,IAAoB,EA1ItB;;AA2IV,0BAAG6B,KAAK,CAACvB,MAAN,GAAe,CAAlB,EAAqB;AACnBuB,wBAAAA,KAAK,GAAGC,KAAK,CAACC,IAAN,CAAWF,KAAX,EAAkBG,IAAlB,EAAR;AACD,uBA7IS,CA8IV;AACA;;;AACMC,sBAAAA,WAhJI,GAgJUnC,SAhJV;AAAA,6DAiJQ+B,KAjJR;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiJAK,sBAAAA,IAjJA;AAkJFC,sBAAAA,aAlJE,GAkJczC,GAAG,CAAC0C,UAAJ,CACpB;AAACtC,wBAAAA,SAAS,EAAEmC,WAAZ;AAAyBI,wBAAAA,GAAG,EAAEH,IAA9B;AAAoCI,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAAhD,uBADoB,CAlJd,EAqJR;;AACMzB,sBAAAA,IAtJE,GAsJItC,gBAAgB,CAACkD,QAAD,EAAWS,aAAX,EAA0B,UAA1B,CAtJpB;;AAAA,0BAuJJzE,YAAY,CAACoD,IAAD,CAvJR;AAAA;AAAA;AAAA;;AAAA;AAAA,6BAwJYlC,eAAe,CAAC;AAChCkB,wBAAAA,SAAS,EAATA,SADgC;AAEhCiB,wBAAAA,QAAQ,EAAED,IAFsB;AAGhCb,wBAAAA,OAAO,EAAPA,OAHgC;AAIhCe,wBAAAA,SAAS,EAAE;AAJqB,uBAAD,CAxJ3B;;AAAA;AAwJNlB,sBAAAA,SAxJM;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAiKV;AACM0C,sBAAAA,IAlKI,GAkKGC,MAAM,CAACD,IAAP,CAAYxC,OAAZ,EAAqBgC,IAArB,EAlKH;AAAA,8DAmKoBQ,IAnKpB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAmKAE,sBAAAA,gBAnKA;AAoKFC,sBAAAA,aApKE,GAoKc3C,OAAO,CAAC0C,gBAAD,CApKrB,EAsKR;;AAtKQ,4BAuKLA,gBAAgB,KAAK,KAvKhB;AAAA;AAAA;AAAA;;AAwKFE,sBAAAA,cAxKE,GAwKetD,QAAQ,CAACqD,aAAD,CAAR,CAAwBE,GAAxB,CACnB,UAAAC,WAAW;AAAA,+BAAIpD,GAAG,CAAC0C,UAAJ,CAAe;AAC5BtC,0BAAAA,SAAS,EAATA,SAD4B;AAE5BuC,0BAAAA,GAAG,EAAES,WAFuB;AAG5BR,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR,2BAHgB;AAI5BQ,0BAAAA,IAAI,EAAE9C,OAAO,CAAC8C;AAJc,yBAAf,CAAJ;AAAA,uBADQ,CAxKf;;AA+KN,0BAAGH,cAAc,CAACtC,MAAf,KAA0B,CAA7B,EAAgC;AAC9BsC,wBAAAA,cAAc,GAAGA,cAAc,CAAC,CAAD,CAA/B;AACD,uBAjLK,CAmLN;;;AACMI,sBAAAA,KApLA,GAoLQtD,GAAG,CAAC0C,UAAJ,CACZ;AAACtC,wBAAAA,SAAS,EAATA,SAAD;AAAYuC,wBAAAA,GAAG,EAAE,KAAjB;AAAwBC,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAApC,uBADY,CApLR;AAuLNnC,sBAAAA,IAAI,CAAC4C,KAAD,CAAJ,GAAcJ,cAAd;AAvLM;;AAAA;AAAA,4BA4LLF,gBAAgB,KAAK,OA5LhB;AAAA;AAAA;AAAA;;AA6LN;AACIE,sBAAAA,eA9LE,GA8LetD,QAAQ,CAACqD,aAAD,CAAR,CAAwBE,GAAxB,CACnB,UAAAC,WAAW;AAAA,+BAAIpD,GAAG,CAAC0C,UAAJ,CAAe;AAC5BtC,0BAAAA,SAAS,EAAE4B,QADiB;AAE5BW,0BAAAA,GAAG,EAAES,WAFuB;AAG5BR,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR;AAHgB,yBAAf,CAAJ;AAAA,uBADQ,CA9Lf;;AAoMN,0BAAGK,eAAc,CAACtC,MAAf,KAA0B,CAA7B,EAAgC;AAC9BsC,wBAAAA,eAAc,GAAGA,eAAc,CAAC,CAAD,CAA/B;AACD,uBAtMK,CAwMN;;;AACMI,sBAAAA,MAzMA,GAyMQtD,GAAG,CAAC0C,UAAJ,CACZ;AAACtC,wBAAAA,SAAS,EAATA,SAAD;AAAYuC,wBAAAA,GAAG,EAAE,OAAjB;AAA0BC,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAAtC,uBADY,CAzMR;AA2MA1B,sBAAAA,WA3MA,GA2MYrC,gBAAgB,CAChCsB,SADgC,EACrBkD,MADqB,EACd,YADc,CAAhB,IACmB,EA5M/B,EA8MN;;AACMC,sBAAAA,SA/MA,GAgNJpC,WAAS,CAACW,QAAV,CAAmB,MAAnB,KACA1C,eAAe,CAACgB,SAAD,EAAY,GAAZ,CAjNX;AAkNAzC,sBAAAA,OAlNA,GAmNJ4F,SAAS,IAAK7F,QAAQ,CAACwF,eAAD,CAAR,IAA4BD,aAAa,CAACrC,MAAd,KAAyB,CAnN/D;;AAoNNlB,sBAAAA,SAAS,CAACgB,IAAD,EAAO4C,MAAP,EAAcJ,eAAd,EAA8B;AAACM,wBAAAA,eAAe,EAAE7F;AAAlB,uBAA9B,CAAT;;AApNM;;AAAA;AAAA,4BAyNLqF,gBAAgB,KAAK,UAzNhB;AAAA;AAAA;AAAA;;AAAA;AAAA,6BA2NuBhD,GAAG,CAACG,OAAJ,CAAY;AACvCC,wBAAAA,SAAS,EAATA,SADuC;AAEvCC,wBAAAA,cAAc,EAAE,UAFuB;AAGvCC,wBAAAA,OAAO,EAAE2C,aAH8B;AAIvC1C,wBAAAA,OAAO,EAAPA,OAJuC;AAKvCC,wBAAAA,aAAa,EAAbA;AALuC,uBAAZ,CA3NvB;;AAAA;AA2NA0C,sBAAAA,gBA3NA;;AAmON;AACA,2BAAUO,iBAAV,IAA+BP,gBAA/B,EAA+C;AAC7C,4BAAG9C,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBF,iBAAvB,KACDrD,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBH,iBAAvB,EAA0CI,OAD5C,EACqD;AAC7ChC,0BAAAA,KAD6C,GACrCqB,gBAAc,CAACO,iBAAD,CADuB;AAE7CtC,0BAAAA,WAF6C,GAEjCrC,gBAAgB,CAChCsB,SADgC,EACrBqD,iBADqB,EACF,YADE,CAAhB,IAC+B,EAHE;AAI7CK,0BAAAA,QAJ6C,GAKjD3C,WAAS,CAACW,QAAV,CAAmB,MAAnB,KAA8B,CAACvB,OAAO,CAACW,aALU;;AAMnDxB,0BAAAA,SAAS,CACPgB,IADO,EACD+C,iBADC,EACkB5B,KADlB,EACyB;AAAC2B,4BAAAA,eAAe,EAAEM;AAAlB,2BADzB,CAAT;;AAEA,iCAAOZ,gBAAc,CAACO,iBAAD,CAArB;AACD;AACF;;AAED,0BAAGV,MAAM,CAACD,IAAP,CAAYI,gBAAZ,EAA4BtC,MAA5B,GAAqC,CAAxC,EAA2C;AACzC;AACM0C,wBAAAA,OAFmC,GAE3BtD,GAAG,CAAC0C,UAAJ,CAAe;AAC3BtC,0BAAAA,SAAS,EAATA,SAD2B;AAE3BuC,0BAAAA,GAAG,EAAEK,gBAFsB;AAG3BJ,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR;AAHe,yBAAf,CAF2B;;AAOzCnD,wBAAAA,SAAS,CAACgB,IAAD,EAAO4C,OAAP,EAAcJ,gBAAd,CAAT;AACD;;AA1PK;;AAAA;AAAA,4BA+PLF,gBAAgB,KAAK,WA/PhB;AAAA;AAAA;AAAA;;AAAA;AAAA,6BAiQuBhD,GAAG,CAACG,OAAJ,CAAY;AACvCC,wBAAAA,SAAS,EAATA,SADuC;AAEvCC,wBAAAA,cAAc,EAAdA,cAFuC;AAGvCC,wBAAAA,OAAO,EAAE2C,aAH8B;AAIvC1C,wBAAAA,OAAO,EAAPA,OAJuC;AAKvCC,wBAAAA,aAAa,EAAbA;AALuC,uBAAZ,CAjQvB;;AAAA;AAiQA0C,sBAAAA,gBAjQA;;AAyQN,0BAAG,EAAExF,QAAQ,CAACwF,gBAAD,CAAR,IAA4BA,gBAAc,CAACtC,MAAf,KAA0B,CAAxD,CAAH,EAA+D;AAC7DlB,wBAAAA,SAAS,CAACgB,IAAD,EAAOsC,gBAAP,EAAyBE,gBAAzB,CAAT;AACD;;AA3QK;;AAAA;AAAA,4BAgRLF,gBAAgB,KAAK,QAhRhB;AAAA;AAAA;AAAA;;AAiRN;AACM7B,sBAAAA,WAlRA,GAkRYrC,gBAAgB,CAChCsB,SADgC,EACrBC,cADqB,EACL,YADK,CAAhB,IAC4B,EAnRxC;;AAAA,2BAoRHc,WAAS,CAACW,QAAV,CAAmB,QAAnB,CApRG;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAwRN;AACMwB,sBAAAA,OAzRA,GAyRQtD,GAAG,CAAC0C,UAAJ,CAAe;AAC3BtC,wBAAAA,SAAS,EAATA,SAD2B;AAE3BuC,wBAAAA,GAAG,EAAEK,gBAFsB;AAG3BJ,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAHe,uBAAf,CAzRR;;AA8RNnD,sBAAAA,SAAS,CAACgB,IAAD,EAAO4C,OAAP,EAAcL,aAAd,CAAT;;AA9RM;;AAAA;AAAA,4BAoSLD,gBAAgB,KAAK,QAArB,IAAiCA,gBAAgB,KAAK,OAAtD,IACDA,gBAAgB,KAAK,WADpB,IAEDhE,UAAU,CAACgE,gBAAD,CAtSJ;AAAA;AAAA;AAAA;;AAuSN;AACMM,sBAAAA,OAxSA,GAwSQtD,GAAG,CAAC0C,UAAJ,CAAe;AAC3BtC,wBAAAA,SAAS,EAATA,SAD2B;AAE3BuC,wBAAAA,GAAG,EAAEK,gBAFsB;AAG3BJ,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAHe,uBAAf,CAxSR;;AA6SNnD,sBAAAA,SAAS,CAACgB,IAAD,EAAO4C,OAAP,EAAcL,aAAd,CAAT;;AA7SM;;AAAA;AAAA,0BAkTJvF,QAAQ,CAACuF,aAAD,CAlTJ;AAAA;AAAA;AAAA;;AAAA,4BAmTA,IAAIzF,WAAJ,CACJ,2DADI,EAEJ,oBAFI,CAnTA;;AAAA;AAwTR;AACA,0BAAGyF,aAAa,CAACrC,MAAd,KAAyB,CAA5B,EAA+B;AACvBmD,wBAAAA,kBADuB,GACF/D,GAAG,CAAC0C,UAAJ,CAAe;AACxCtC,0BAAAA,SAAS,EAATA,SADwC;AAExCuC,0BAAAA,GAAG,EAAEK,gBAFmC;AAGxCnB,0BAAAA,KAAK,EAAEoB,aAHiC;AAIxCL,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR,2BAJ4B;AAKxCgB,0BAAAA,OAAO,EAAE9B;AAL+B,yBAAf,CADE;AAQvBiC,wBAAAA,YARuB,GAQR5D,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBI,kBAAvB,IACnB3D,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBG,kBAAvB,EAA2C,OAA3C,CADmB,GACmC,IAT3B;AAUzBE,wBAAAA,UAVyB,GAUZvD,IAVY;;AAW7B,4BAAGsD,YAAH,EAAiB;AACfE,0BAAAA,kBAAkB,CAAC9D,SAAD,EAAY4D,YAAZ,EAA0BzD,OAA1B,CAAlB;;AACA,8BAAG,CAAC3C,SAAS,CAAC8C,IAAI,CAACsD,YAAD,CAAL,CAAb,EAAmC;AACjCtD,4BAAAA,IAAI,CAACsD,YAAD,CAAJ,GAAqB,EAArB;AACD;;AACDC,0BAAAA,UAAU,GAAGvD,IAAI,CAACsD,YAAD,CAAjB;AACD;;AACDtE,wBAAAA,SAAS,CACPuE,UADO,EACKF,kBADL,EACyBd,aADzB,EACwC;AAC7CO,0BAAAA,eAAe,EAAE;AAD4B,yBADxC,CAAT;AAID,uBA/UO,CAiVR;;;AAjVQ,8DAkVkBP,aAlVlB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkVEkB,sBAAAA,YAlVF;AAmVN;AACMJ,sBAAAA,mBApVA,GAoVqB/D,GAAG,CAAC0C,UAAJ,CAAe;AACxCtC,wBAAAA,SAAS,EAATA,SADwC;AAExCuC,wBAAAA,GAAG,EAAEK,gBAFmC;AAGxCnB,wBAAAA,KAAK,EAAEsC,YAHiC;AAIxCvB,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR,yBAJ4B;AAKxCgB,wBAAAA,OAAO,EAAE9B;AAL+B,uBAAf,CApVrB,EA4VN;AACA;;AACMiC,sBAAAA,aA9VA,GA8Ve5D,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBI,mBAAvB,IACnB3D,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBG,mBAAvB,EAA2C,OAA3C,CADmB,GACmC,IA/VlD;AAgWFE,sBAAAA,WAhWE,GAgWWvD,IAhWX;;AAiWN,0BAAGsD,aAAH,EAAiB;AACfE,wBAAAA,kBAAkB,CAAC9D,SAAD,EAAY4D,aAAZ,EAA0BzD,OAA1B,CAAlB;;AACA,4BAAG,CAAC3C,SAAS,CAAC8C,IAAI,CAACsD,aAAD,CAAL,CAAb,EAAmC;AACjCtD,0BAAAA,IAAI,CAACsD,aAAD,CAAJ,GAAqB,EAArB;AACD;;AACDC,wBAAAA,WAAU,GAAGvD,IAAI,CAACsD,aAAD,CAAjB;AACD;;AAEK7C,sBAAAA,WAzWA,GAyWYrC,gBAAgB,CAChCsB,SADgC,EACrB2D,mBADqB,EACD,YADC,CAAhB,IACgC,EA1W5C,EA4WN;;AACMxF,sBAAAA,OA7WA,GA6WUD,QAAQ,CAAC6F,YAAD,CA7WlB;AA8WAhG,sBAAAA,MA9WA,GA8WSD,OAAO,CAACiG,YAAD,CA9WhB;AA+WFC,sBAAAA,KA/WE;;AAgXN,0BAAGjG,MAAH,EAAW;AACTiG,wBAAAA,KAAK,GAAGD,YAAY,CAAC,OAAD,CAApB;AACD,uBAFD,MAEO,IAAG5F,OAAH,EAAY;AACjB6F,wBAAAA,KAAK,GAAGD,YAAY,CAAC,QAAD,CAApB;AACD,uBApXK,CAsXN;;;AAtXM;AAAA,6BAuXoBnE,GAAG,CAACG,OAAJ,CAAY;AACpCC,wBAAAA,SAAS,EAATA,SADoC;AAEpCC,wBAAAA,cAAc,EAAE0D,mBAFoB;AAGpCzD,wBAAAA,OAAO,EAAGnC,MAAM,IAAII,OAAX,GAAsB6F,KAAtB,GAA8BD,YAHH;AAIpC5D,wBAAAA,OAAO,EAAPA,OAJoC;AAKpCC,wBAAAA,aAAa,EAAbA;AALoC,uBAAZ,CAvXpB;;AAAA;AAuXF6D,sBAAAA,aAvXE;;AAAA,2BAgYHlG,MAhYG;AAAA;AAAA;AAAA;;AAiYJ;AACA,0BAAG,CAACT,QAAQ,CAAC2G,aAAD,CAAZ,EAA6B;AAC3BA,wBAAAA,aAAa,GAAG,CAACA,aAAD,CAAhB;AACD;;AApYG,0BAsYAlD,WAAS,CAACW,QAAV,CAAmB,OAAnB,CAtYA;AAAA;AAAA;AAAA;;AAuYF;AACAuC,sBAAAA,aAAa,uBACVrE,GAAG,CAAC0C,UAAJ,CAAe;AACdtC,wBAAAA,SAAS,EAATA,SADc;AAEduC,wBAAAA,GAAG,EAAE,OAFS;AAGdC,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAHE,uBAAf,CADU,EAKNwB,aALM,CAAb,CAxYE,CAgZF;;AACA,0BAAG,YAAYF,YAAf,EAA6B;AAC3BE,wBAAAA,aAAa,CAACrE,GAAG,CAAC0C,UAAJ,CAAe;AAC3BtC,0BAAAA,SAAS,EAATA,SAD2B;AAE3BuC,0BAAAA,GAAG,EAAE,QAFsB;AAG3BC,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR;AAHe,yBAAf,CAAD,CAAb,GAIMsB,YAAY,CAAC,QAAD,CAJlB;AAKD;;AAvZC;AAAA;;AAAA;AAyZFzE,sBAAAA,SAAS,CAACuE,WAAD,EAAaF,mBAAb,EAAiCM,aAAjC,EAAgD;AACvDC,wBAAAA,YAAY,EAAE,IADyC;AAEvDC,wBAAAA,cAAc,EAAE;AAFuC,uBAAhD,CAAT;;AAzZE;;AAAA;AAAA,2BAkaHhG,OAlaG;AAAA;AAAA;AAAA;;AAmaJ,0BAAG4C,WAAS,CAACW,QAAV,CAAmB,QAAnB,MAAiCX,WAAS,CAACW,QAAV,CAAmB,KAAnB,KAClCX,WAAS,CAACW,QAAV,CAAmB,QAAnB,KAAgCtD,cAAc,CAAC2F,YAAD,CAD7C,CAAH,EACiE;AAC/D;AACIK,wBAAAA,SAF2D;;AAG/D,4BAAGP,WAAU,CAACxC,cAAX,CAA0BsC,mBAA1B,CAAH,EAAkD;AAChDS,0BAAAA,SAAS,GAAGP,WAAU,CAACF,mBAAD,CAAtB;AACD,yBAFD,MAEO;AACLE,0BAAAA,WAAU,CAACF,mBAAD,CAAV,GAAiCS,SAAS,GAAG,EAA7C;AACD,yBAP8D,CAS/D;;;AACMC,wBAAAA,GAVyD,GAUnD,CAACtD,WAAS,CAACW,QAAV,CAAmB,KAAnB,IACXqC,YAAY,CAAC,KAAD,CADD,GACWA,YAAY,CAAC,QAAD,CADxB,KAEVnE,GAAG,CAAC0C,UAAJ,CAAe;AAACtC,0BAAAA,SAAS,EAATA,SAAD;AAAYuC,0BAAAA,GAAG,EAAE,OAAjB;AACbC,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR;AADC,yBAAf,CAZ6D,EAc/D;AACA;;AAEAnD,wBAAAA,SAAS,CACP8E,SADO,EACIC,GADJ,EACSJ,aADT,EACwB;AAC7Bb,0BAAAA,eAAe,EACZ,CAACjD,OAAO,CAACW,aAAT,IAA0BC,WAAS,CAACW,QAAV,CAAmB,MAAnB;AAFA,yBADxB,CAAT;AAKD,uBAvBD,MAuBO,IAAGX,WAAS,CAACW,QAAV,CAAmB,QAAnB,KACRtD,cAAc,CAAC2F,YAAD,CADT,EACyB;AAC9B;AACA;AACA;AACA;AACA,4BAAGzG,QAAQ,CAAC2G,aAAD,CAAR,IAA2BA,aAAa,CAACzD,MAAd,GAAuB,CAArD,EAAwD;AACtDyD,0BAAAA,aAAa,GAAG;AAAC,yCAAaA;AAAd,2BAAhB;AACD;;AACD3E,wBAAAA,SAAS,CACPuE,WADO,EACKF,mBADL,EACyBM,aADzB,EACwC;AAC7Cb,0BAAAA,eAAe,EACZ,CAACjD,OAAO,CAACW,aAAT,IAA0BC,WAAS,CAACW,QAAV,CAAmB,MAAnB;AAFgB,yBADxC,CAAT;AAKD,uBAdM,MAcA;AACL;AACA;AACA,4BAAGpE,QAAQ,CAAC2G,aAAD,CAAR,IAA2BA,aAAa,CAACzD,MAAd,KAAyB,CAApD,IACDL,OAAO,CAACW,aADV,EACyB;AACvBmD,0BAAAA,aAAa,GAAGA,aAAa,CAAC,CAAD,CAA7B;AACD;;AACDA,wBAAAA,aAAa,uBACVrE,GAAG,CAAC0C,UAAJ,CAAe;AACdtC,0BAAAA,SAAS,EAATA,SADc;AAEduC,0BAAAA,GAAG,EAAE,QAFS;AAGdC,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR;AAHE,yBAAf,CADU,EAKNwB,aALM,CAAb,CAPK,CAeL;;AACA,4BAAG,SAASF,YAAZ,EAA0B;AACxBE,0BAAAA,aAAa,CAACrE,GAAG,CAAC0C,UAAJ,CAAe;AAC3BtC,4BAAAA,SAAS,EAATA,SAD2B;AAE3BuC,4BAAAA,GAAG,EAAE,KAFsB;AAG3BC,4BAAAA,UAAU,EAAE;AAACC,8BAAAA,KAAK,EAAE;AAAR;AAHe,2BAAf,CAAD,CAAb,GAIMsB,YAAY,CAAC,KAAD,CAJlB;AAKD,yBAtBI,CAwBL;;;AACA,4BAAG,YAAYA,YAAf,EAA6B;AAC3BE,0BAAAA,aAAa,CAACrE,GAAG,CAAC0C,UAAJ,CAAe;AAC3BtC,4BAAAA,SAAS,EAATA,SAD2B;AAE3BuC,4BAAAA,GAAG,EAAE,QAFsB;AAG3BC,4BAAAA,UAAU,EAAE;AAACC,8BAAAA,KAAK,EAAE;AAAR;AAHe,2BAAf,CAAD,CAAb,GAIMsB,YAAY,CAAC,QAAD,CAJlB;AAKD;;AACDzE,wBAAAA,SAAS,CACPuE,WADO,EACKF,mBADL,EACyBM,aADzB,EACwC;AAC7Cb,0BAAAA,eAAe,EACZ,CAACjD,OAAO,CAACW,aAAT,IAA0BC,WAAS,CAACW,QAAV,CAAmB,MAAnB;AAFgB,yBADxC,CAAT;AAKD;;AA7eG;AAAA;;AAAA;AAAA,4BA8eIX,WAAS,CAACW,QAAV,CAAmB,WAAnB,KACRX,WAAS,CAACW,QAAV,CAAmB,QAAnB,CADQ,IACwBX,WAAS,CAACW,QAAV,CAAmB,KAAnB,CADxB,IAERX,WAAS,CAACW,QAAV,CAAmB,OAAnB,CAhfI;AAAA;AAAA;AAAA;;AAifJ;AACA;AACI0C,sBAAAA,UAnfA;;AAofJ,0BAAGP,WAAU,CAACxC,cAAX,CAA0BsC,mBAA1B,CAAH,EAAkD;AAChDS,wBAAAA,UAAS,GAAGP,WAAU,CAACF,mBAAD,CAAtB;AACD,uBAFD,MAEO;AACLE,wBAAAA,WAAU,CAACF,mBAAD,CAAV,GAAiCS,UAAS,GAAG,EAA7C;AACD;;AAEGC,sBAAAA,IA1fA;;AAAA,2BA2fDtD,WAAS,CAACW,QAAV,CAAmB,WAAnB,CA3fC;AAAA;AAAA;AAAA;;AA4fJ;AACA;AACE,0BAAG1D,QAAQ,CAACiG,aAAD,CAAX,EAA4B;AAC1BA,wBAAAA,aAAa,GAAGA,aAAa,CAAC,QAAD,CAA7B;AACD;;AACDI,sBAAAA,IAAG,GAAGN,YAAY,CAAC,WAAD,CAAlB;AAjgBE;AAAA;;AAAA;AAAA,2BAkgBMhD,WAAS,CAACW,QAAV,CAAmB,QAAnB,CAlgBN;AAAA;AAAA;AAAA;;AAmgBI4C,sBAAAA,QAngBJ,GAmgBe5F,gBAAgB,CAC/BsB,SAD+B,EACpB2D,mBADoB,EACA,QADA,CAAhB,IAC6B,QApgB5C;AAqgBIY,sBAAAA,YArgBJ,GAqgBmB3E,GAAG,CAAC0C,UAAJ,CACnB;AAACtC,wBAAAA,SAAS,EAATA,SAAD;AAAYuC,wBAAAA,GAAG,EAAE+B,QAAjB;AAA2B9B,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAAvC,uBADmB,CArgBnB;;AAAA,4BAugBC6B,QAAQ,KAAK,QAvgBd;AAAA;AAAA;AAAA;;AAwgBAD,sBAAAA,IAAG,GAAGN,YAAY,CAAC,QAAD,CAAlB;AACA,6BAAOE,aAAa,CAACM,YAAD,CAApB;AAzgBA;AAAA;;AAAA;AA2gBIC,sBAAAA,MA3gBJ;AAAA,kCA4gBmBhF,QAAQ,CAACyE,aAAa,CAACK,QAAD,CAAb,IAA2B,EAA5B,CA5gB3B;AAAA;AA4gBCD,sBAAAA,IA5gBD;AA4gBSG,sBAAAA,MA5gBT;;AAAA,0BA6gBI9G,SAAS,CAAC2G,IAAD,CA7gBb;AAAA;AAAA;AAAA;;AA8gBE;AACAA,sBAAAA,IAAG,GAAG,IAAN;AA/gBF;AAAA;;AAAA;AAAA,oCAihBSG,MAAM,CAAChE,MAjhBhB;AAAA,sDAkhBS,CAlhBT,yBAqhBS,CArhBT;AAAA;;AAAA;AAmhBM,6BAAOyD,aAAa,CAACK,QAAD,CAApB;AAnhBN;;AAAA;AAshBML,sBAAAA,aAAa,CAACK,QAAD,CAAb,GAA0BE,MAAM,CAAC,CAAD,CAAhC;AAthBN;;AAAA;AAyhBMP,sBAAAA,aAAa,CAACK,QAAD,CAAb,GAA0BE,MAA1B;AAzhBN;;AAAA;AAAA;AAAA;;AAAA;AAAA,2BA8hBMzD,WAAS,CAACW,QAAV,CAAmB,KAAnB,CA9hBN;AAAA;AAAA;AAAA;;AA+hBI+C,sBAAAA,KA/hBJ,GA+hBY7E,GAAG,CAAC0C,UAAJ,CAAe;AAACtC,wBAAAA,SAAS,EAATA,SAAD;AAAYuC,wBAAAA,GAAG,EAAE,KAAjB;AAC3BC,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AADe,uBAAf,CA/hBZ;AAiiBF4B,sBAAAA,IAAG,GAAGJ,aAAa,CAACQ,KAAD,CAAnB;AACA,6BAAOR,aAAa,CAACQ,KAAD,CAApB;AAliBE;AAAA;;AAAA;AAAA,2BAmiBM1D,WAAS,CAACW,QAAV,CAAmB,OAAnB,CAniBN;AAAA;AAAA;AAAA;;AAoiBIgD,sBAAAA,OApiBJ,GAoiBc9E,GAAG,CAAC0C,UAAJ,CAAe;AAC7BtC,wBAAAA,SAAS,EAATA,SAD6B;AAE7BuC,wBAAAA,GAAG,EAAE,OAFwB;AAG7BC,wBAAAA,UAAU,EAAE;AAACC,0BAAAA,KAAK,EAAE;AAAR;AAHiB,uBAAf,CApiBd;AAyiBEV,sBAAAA,MAziBF;AAAA,kCA0iBgBvC,QAAQ,CAACyE,aAAa,CAACS,OAAD,CAAb,IAA0B,EAA3B,CA1iBxB;AAAA;AA0iBDL,sBAAAA,IA1iBC;AA0iBOtC,sBAAAA,MA1iBP;AAAA,oCA2iBKA,MAAK,CAACvB,MA3iBX;AAAA,sDA4iBK,CA5iBL,yBA+iBK,CA/iBL;AAAA;;AAAA;AA6iBE,6BAAOyD,aAAa,CAACS,OAAD,CAApB;AA7iBF;;AAAA;AAgjBET,sBAAAA,aAAa,CAACS,OAAD,CAAb,GAAyB3C,MAAK,CAAC,CAAD,CAA9B;AAhjBF;;AAAA;AAmjBEkC,sBAAAA,aAAa,CAACS,OAAD,CAAb,GAAyB3C,MAAzB;AAnjBF;;AAAA;AAAA,4BAyjBCY,MAAM,CAACD,IAAP,CAAYuB,aAAZ,EAA2BzD,MAA3B,KAAsC,CAAtC,IACD,SAASuD,YA1jBT;AAAA;AAAA;AAAA;;AAAA;AAAA,6BA2jBsBnE,GAAG,CAACG,OAAJ,CAAY;AAChCC,wBAAAA,SAAS,EAATA,SADgC;AAEhCC,wBAAAA,cAAc,EAAE0D,mBAFgB;AAGhCzD,wBAAAA,OAAO,EAAE;AAAC,iCAAO6D,YAAY,CAAC,KAAD;AAApB,yBAHuB;AAIhC5D,wBAAAA,OAAO,EAAPA,OAJgC;AAKhCC,wBAAAA,aAAa,EAAbA;AALgC,uBAAZ,CA3jBtB;;AAAA;AA2jBA6D,sBAAAA,aA3jBA;;AAAA;AAqkBJ;AACA,0BAAG,CAACI,IAAJ,EAAS;AACPA,wBAAAA,IAAG,GAAGzE,GAAG,CAAC0C,UAAJ,CAAe;AAACtC,0BAAAA,SAAS,EAATA,SAAD;AAAYuC,0BAAAA,GAAG,EAAE,OAAjB;AACnBC,0BAAAA,UAAU,EAAE;AAACC,4BAAAA,KAAK,EAAE;AAAR;AADO,yBAAf,CAAN;AAED,uBAzkBG,CA0kBJ;AACA;;;AACAnD,sBAAAA,SAAS,CACP8E,UADO,EACIC,IADJ,EACSJ,aADT,EACwB;AAC7Bb,wBAAAA,eAAe,EAAErC,WAAS,CAACW,QAAV,CAAmB,MAAnB;AADY,uBADxB,CAAT;;AA5kBI;AAAA;;AAAA;AAilBJ;AACA;AACA;AACMnE,sBAAAA,SAplBF,GAolBa,CAAC4C,OAAO,CAACW,aAAT,IACfC,WAAS,CAACW,QAAV,CAAmB,MAAnB,CADe,IACeX,WAAS,CAACW,QAAV,CAAmB,OAAnB,CADf,IAEdpE,QAAQ,CAAC2G,aAAD,CAAR,IAA2BA,aAAa,CAACzD,MAAd,KAAyB,CAFtC,IAGfoC,gBAAgB,KAAK,OAHN,IAGiBA,gBAAgB,KAAK,QAvlBnD,EAylBJ;;AACAtD,sBAAAA,SAAS,CACPuE,WADO,EACKF,mBADL,EACyBM,aADzB,EAEP;AAACb,wBAAAA,eAAe,EAAE7F;AAAlB,uBAFO,CAAT;;AA1lBI;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;AAAA;;AAAA;AAAA;AAAA,2BAimBH+C;AAjmBG;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,8CAqmBLJ,OArmBK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAd;;AAAA;AAAA;AAAA;AAAA;AAwmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,GAAG,CAAC0C,UAAJ,GAAiB,iBAOX;AAAA,MANJtC,SAMI,SANJA,SAMI;AAAA,MALJuC,GAKI,SALJA,GAKI;AAAA,0BAJJd,KAII;AAAA,MAJJA,KAII,4BAJI,IAIJ;AAAA,+BAHJe,UAGI;AAAA,MAHJA,UAGI,iCAHS;AAACC,IAAAA,KAAK,EAAE;AAAR,GAGT;AAAA,4BAFJgB,OAEI;AAAA,MAFJA,OAEI,8BAFM,KAEN;AAAA,yBADJR,IACI;AAAA,MADJA,IACI,2BADG,IACH;;AACJ;AACA,MAAGV,GAAG,KAAK,IAAX,EAAiB;AACf,WAAOA,GAAP;AACD,GAJG,CAMJ;AACA;;;AACA,MAAGvC,SAAS,CAAC2E,oBAAV,IAAkC3E,SAAS,CAAC4E,eAA/C,EAAgE;AAC9D5E,IAAAA,SAAS,GAAGA,SAAS,CAAC4E,eAAtB;AACD;;AAED,MAAMC,UAAU,GAAG7E,SAAS,CAAC8E,UAAV,EAAnB,CAZI,CAcJ;;AACA,MAAGlG,UAAU,CAAC2D,GAAD,CAAV,IACDA,GAAG,IAAIsC,UADN,IAED,WAAWA,UAAU,CAACtC,GAAD,CAFpB,IAGD,WAAWsC,UAAU,CAACtC,GAAD,CAAV,CAAgB,OAAhB,CAHV,IAID,WAAWsC,UAAU,CAACtC,GAAD,CAAV,CAAgB,OAAhB,EAAyB,OAAzB,CAJb,EAIgD;AAC9C,WAAOsC,UAAU,CAACtC,GAAD,CAAV,CAAgB,OAAhB,EAAyB,OAAzB,EAAkC,OAAlC,CAAP;AACD,GArBG,CAuBJ;;;AACA,MAAGC,UAAU,CAACC,KAAX,IAAoBF,GAAG,IAAIsC,UAA9B,EAA0C;AACxC,QAAME,eAAe,GAAG/E,SAAS,CAAC,WAAD,CAAT,IAA0B,OAAlD,CADwC,CAGxC;;AACA,QAAMgF,UAAU,GAAG,EAAnB;;AACA,QAAGxH,SAAS,CAACiE,KAAD,CAAT,IAAoB,YAAYA,KAAhC,IAAyC,EAAE,YAAYA,KAAd,CAA5C,EAAkE;AAChEuD,MAAAA,UAAU,CAACnE,IAAX,CAAgB,QAAhB,EAA0B,YAA1B;AACD,KAPuC,CASxC;;;AACA,QAAGrD,SAAS,CAACiE,KAAD,CAAT,IAAoB,eAAeA,KAAtC,EAA6C;AAC3CA,MAAAA,KAAK,GAAGA,KAAK,CAAC,WAAD,CAAL,CAAmB,CAAnB,CAAR;AACD,KAZuC,CAcxC;AACA;;;AACA,QAAGvD,QAAQ,CAACuD,KAAD,CAAX,EAAoB;AAClB;AACA,UAAG,YAAYA,KAAf,EAAsB;AACpBuD,QAAAA,UAAU,CAACnE,IAAX,CACE,cADF,EACkB,kBADlB,EACsC,QADtC,EACgD,YADhD;AAED,OALiB,CAMlB;;;AACA,UAAG,SAASY,KAAZ,EAAmB;AACjBuD,QAAAA,UAAU,CAACnE,IAAX,CACE,WADF,EACe,eADf;AAED;;AACDmE,MAAAA,UAAU,CAACnE,IAAX,CAAgB,QAAhB,EAA0B,YAA1B,EAAwC,MAAxC,EAXkB,CAYlB;;AACA,UAAG,EAAE,YAAYY,KAAd,CAAH,EAAyB;AACvBuD,QAAAA,UAAU,CAACnE,IAAX,CACE,cADF,EACkB,kBADlB,EACsC,QADtC,EACgD,YADhD;AAED,OAhBiB,CAiBlB;;;AACA,UAAG,EAAE,SAASY,KAAX,CAAH,EAAsB;AACpBuD,QAAAA,UAAU,CAACnE,IAAX,CAAgB,WAAhB,EAA6B,eAA7B;AACD;AACF,KArBD,MAqBO,IAAGrD,SAAS,CAACiE,KAAD,CAAT,IAAoB,CAACzD,QAAQ,CAACyD,KAAD,CAAhC,EAAyC;AAC9CuD,MAAAA,UAAU,CAACnE,IAAX,CAAgB,KAAhB,EAAuB,SAAvB,EAAkC,OAAlC,EAA2C,WAA3C;AACD,KAvCuC,CAyCxC;;;AACA,QAAIoE,cAAc,GAAG,WAArB;AACA,QAAIC,mBAAmB,GAAG,OAA1B;;AAEA,QAAGzB,OAAH,EAAY;AACVwB,MAAAA,cAAc,GAAG,OAAjB;AACAC,MAAAA,mBAAmB,GAAG,UAAtB;AACAF,MAAAA,UAAU,CAACnE,IAAX,CAAgB,MAAhB;AACD,KAJD,MAIO,IAAG/C,OAAO,CAAC2D,KAAD,CAAV,EAAmB;AACxB;AACA;AACA,UAAG,EAAE,YAAYA,KAAd,CAAH,EAAyB;AACvBuD,QAAAA,UAAU,CAACnE,IAAX,CAAgB,OAAhB;AACD;;AACD,UAAMsE,IAAI,GAAG1D,KAAK,CAAC,OAAD,CAAlB;;AACA,UAAG0D,IAAI,CAAC3E,MAAL,KAAgB,CAAnB,EAAsB;AACpB;AACA;AACAyE,QAAAA,cAAc,GAAG,MAAjB;AACAC,QAAAA,mBAAmB,GAAG,OAAtB;AACD,OALD,MAKO;AACL,YAAIE,cAAc,GAAID,IAAI,CAAC3E,MAAL,KAAgB,CAAjB,GAAsBuE,eAAtB,GAAwC,IAA7D;AACA,YAAIM,UAAU,GAAG,IAAjB;;AACA,aAAI,IAAI9E,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG4E,IAAI,CAAC3E,MAAxB,EAAgC,EAAED,CAAlC,EAAqC;AACnC,cAAM+E,IAAI,GAAGH,IAAI,CAAC5E,CAAD,CAAjB;AACA,cAAIgF,YAAY,GAAG,OAAnB;AACA,cAAIC,QAAQ,GAAG,OAAf;;AACA,cAAGxH,QAAQ,CAACsH,IAAD,CAAX,EAAmB;AACjB,gBAAG,gBAAgBA,IAAnB,EAAyB;AACvB,kBAAMG,IAAI,GAAG,CAACH,IAAI,CAAC,WAAD,CAAJ,IAAqB,EAAtB,EAA0BI,WAA1B,EAAb;AACA,kBAAMC,GAAG,GAAGL,IAAI,CAAC,YAAD,CAAhB;AACAC,cAAAA,YAAY,aAAME,IAAN,cAAcE,GAAd,CAAZ;AACD,aAJD,MAIO,IAAG,eAAeL,IAAlB,EAAwB;AAC7BC,cAAAA,YAAY,GAAGD,IAAI,CAAC,WAAD,CAAJ,CAAkBI,WAAlB,EAAf;AACD,aAFM,MAEA,IAAG,WAAWJ,IAAd,EAAoB;AACzBE,cAAAA,QAAQ,GAAGF,IAAI,CAAC,OAAD,CAAf;AACD,aAFM,MAEA;AACL;AACAC,cAAAA,YAAY,GAAG,OAAf;AACD;AACF,WAbD,MAaO;AACLC,YAAAA,QAAQ,GAAG,KAAX;AACD;;AACD,cAAGJ,cAAc,KAAK,IAAtB,EAA4B;AAC1BA,YAAAA,cAAc,GAAGG,YAAjB;AACD,WAFD,MAEO,IAAGA,YAAY,KAAKH,cAAjB,IAAmCpH,QAAQ,CAACsH,IAAD,CAA9C,EAAsD;AAC3DF,YAAAA,cAAc,GAAG,OAAjB;AACD;;AACD,cAAGC,UAAU,KAAK,IAAlB,EAAwB;AACtBA,YAAAA,UAAU,GAAGG,QAAb;AACD,WAFD,MAEO,IAAGA,QAAQ,KAAKH,UAAhB,EAA4B;AACjCA,YAAAA,UAAU,GAAG,OAAb;AACD,WA7BkC,CA8BnC;AACA;;;AACA,cAAGD,cAAc,KAAK,OAAnB,IAA8BC,UAAU,KAAK,OAAhD,EAAyD;AACvD;AACD;AACF;;AACDD,QAAAA,cAAc,GAAGA,cAAc,IAAI,OAAnC;AACAC,QAAAA,UAAU,GAAGA,UAAU,IAAI,OAA3B;;AACA,YAAGA,UAAU,KAAK,OAAlB,EAA2B;AACzBJ,UAAAA,cAAc,GAAG,OAAjB;AACAC,UAAAA,mBAAmB,GAAGG,UAAtB;AACD,SAHD,MAGO;AACLH,UAAAA,mBAAmB,GAAGE,cAAtB;AACD;AACF;AACF,KA5DM,MA4DA;AACL,UAAGpH,QAAQ,CAACyD,KAAD,CAAX,EAAoB;AAClB,YAAG,eAAeA,KAAf,IAAwB,EAAE,YAAYA,KAAd,CAA3B,EAAiD;AAC/CuD,UAAAA,UAAU,CAACnE,IAAX,CAAgB,WAAhB,EAA6B,eAA7B;AACAqE,UAAAA,mBAAmB,GAAGzD,KAAK,CAAC,WAAD,CAA3B;AACA,cAAMkE,IAAG,GAAGlE,KAAK,CAAC,YAAD,CAAjB;;AACA,cAAGkE,IAAH,EAAQ;AACNT,YAAAA,mBAAmB,aAAMA,mBAAN,cAA6BS,IAA7B,CAAnB;AACD;AACF,SAPD,MAOO,IAAG,gBAAgBlE,KAAhB,IAAyB,EAAE,YAAYA,KAAd,CAA5B,EAAkD;AACvDyD,UAAAA,mBAAmB,cAAOzD,KAAK,CAAC,YAAD,CAAZ,CAAnB;AACD,SAFM,MAEA,IAAG,WAAWA,KAAd,EAAqB;AAC1BwD,UAAAA,cAAc,GAAG,OAAjB;AACAC,UAAAA,mBAAmB,GAAGzD,KAAK,CAAC,OAAD,CAA3B;AACD;AACF,OAdD,MAcO;AACLwD,QAAAA,cAAc,GAAG,OAAjB;AACAC,QAAAA,mBAAmB,GAAG,KAAtB;AACD;;AACDF,MAAAA,UAAU,CAACnE,IAAX,CAAgB,MAAhB;AACD,KAjIuC,CAmIxC;;;AACAmE,IAAAA,UAAU,CAACnE,IAAX,CAAgB,OAAhB,EApIwC,CAsIxC;AACA;;AACA,QAAGrD,SAAS,CAACiE,KAAD,CAAT,IAAoB,EAAE,YAAYA,KAAd,CAAvB,EAA6C;AAC3C;AACAuD,MAAAA,UAAU,CAACnE,IAAX,CAAgB,QAAhB,EAA0B,YAA1B;AACD,KA3IuC,CA6IxC;;;AACA,QAAG7C,QAAQ,CAACyD,KAAD,CAAR,IAAmBkB,MAAM,CAACD,IAAP,CAAYjB,KAAZ,EAAmBjB,MAAnB,KAA8B,CAApD,EAAuD;AACrD;AACAwE,MAAAA,UAAU,CAACnE,IAAX,CAAgB,WAAhB,EAA6B,eAA7B;AACD;;AAED,QAAM+E,IAAI,GAAGC,WAAW,CACtB7F,SADsB,EACXuC,GADW,EACNd,KADM,EACCuD,UADD,EACaC,cADb,EAC6BC,mBAD7B,CAAxB;;AAEA,QAAGU,IAAI,KAAK,IAAZ,EAAkB;AAChB,aAAOA,IAAP;AACD;AACF,GAhLG,CAkLJ;;;AACA,MAAGpD,UAAU,CAACC,KAAd,EAAqB;AACnB,QAAG,YAAYzC,SAAf,EAA0B;AACxB;AACA,UAAMyC,KAAK,GAAGzC,SAAS,CAAC,QAAD,CAAvB;;AACA,UAAGuC,GAAG,CAACuD,OAAJ,CAAYrD,KAAZ,MAAuB,CAAvB,IAA4BF,GAAG,KAAKE,KAAvC,EAA8C;AAC5C;AACA,YAAMsD,MAAM,GAAGxD,GAAG,CAACyD,MAAJ,CAAWvD,KAAK,CAACjC,MAAjB,CAAf;;AACA,YAAG,CAACR,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBwC,MAAvB,CAAJ,EAAoC;AAClC,iBAAOA,MAAP;AACD;AACF;AACF;AACF,GA/LG,CAiMJ;;;AACA,MAAIE,MAAM,GAAG,IAAb,CAlMI,CAmMJ;;AACA,MAAMC,cAAc,GAAG,EAAvB;AACA,MAAIC,MAAM,GAAGnG,SAAS,CAACoG,YAAvB,CArMI,CAsMJ;AACA;;AACA,MAAMC,gBAAgB,GAAG9D,GAAG,CAAC/B,MAAJ,GAAa,CAAtC;;AACA,OAAI,IAAID,GAAC,GAAG,CAAZ,EAAeA,GAAC,GAAG8F,gBAAJ,IAAwB9D,GAAG,CAAChC,GAAD,CAAH,IAAU4F,MAAjD,EAAyD,EAAE5F,GAA3D,EAA8D;AAC5D4F,IAAAA,MAAM,GAAGA,MAAM,CAAC5D,GAAG,CAAChC,GAAD,CAAJ,CAAf;;AACA,QAAG,MAAM4F,MAAT,EAAiB;AACfD,MAAAA,cAAc,CAACrF,IAAf,CAAoBsF,MAAM,CAAC,EAAD,CAAN,CAAW,CAAX,CAApB;AACD;AACF,GA9MG,CA+MJ;;;AACA,OAAI,IAAI5F,GAAC,GAAG2F,cAAc,CAAC1F,MAAf,GAAwB,CAApC,EAAuCD,GAAC,IAAI,CAA5C,EAA+C,EAAEA,GAAjD,EAAoD;AAClD,QAAM+F,KAAK,GAAGJ,cAAc,CAAC3F,GAAD,CAA5B;AACA,QAAMgG,KAAK,GAAGD,KAAK,CAACC,KAApB;;AAFkD,gDAGhCA,KAHgC;AAAA;;AAAA;AAGlD,6DAAyB;AAAA,YAAfX,KAAe;AACvB;AACA;AACA;AACA;AACA,YAAMY,KAAK,GAAGZ,KAAI,GAAG,GAAP,GAAarD,GAAG,CAACyD,MAAJ,CAAWM,KAAK,CAAC/D,GAAN,CAAU/B,MAArB,CAA3B;AACA,YAAMiG,aAAa,GAAIzG,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBoC,KAAvB,EAA6Bc,OAA7B,KACpB,CAAC1G,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBiD,KAAvB,CAAD,IACA/E,KAAK,KAAK,IAAV,IAAkBzB,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBgD,KAAvB,EAA8B,KAA9B,MAAyCjE,GAFvC,CAAvB,CANuB,CAUvB;AACA;;AACA,YAAGkE,aAAa,KAAKR,MAAM,KAAK,IAAX,IACnBvG,qBAAqB,CAAC8G,KAAD,EAAQP,MAAR,CAArB,GAAuC,CADzB,CAAhB,EAC6C;AAC3CA,UAAAA,MAAM,GAAGO,KAAT;AACD;AACF;AAnBiD;AAAA;AAAA;AAAA;AAAA;AAoBnD,GApOG,CAsOJ;;;AACA,MAAGP,MAAM,KAAK,IAAd,EAAoB;AAClB,WAAOA,MAAP;AACD,GAzOG,CA2OJ;AACA;;;AA5OI,8CA6OoBjG,SAAS,CAACsD,QA7O9B;AAAA;;AAAA;AA6OJ,2DAA4C;AAAA;AAAA,UAAjCsC,MAAiC;AAAA,UAA3Be,EAA2B;;AAC1C,UAAGA,EAAE,IAAIA,EAAE,CAACD,OAAT,IAAoBnE,GAAG,CAACqE,UAAJ,CAAehB,MAAI,GAAG,GAAtB,CAAvB,EAAmD;AACjD,cAAM,IAAIxI,WAAJ,0BACamF,GADb,uCAC2CqD,MAD3C,UAEJ,oBAFI,EAGJ;AAACiB,UAAAA,IAAI,EAAE,0BAAP;AAAmCC,UAAAA,OAAO,EAAE9G;AAA5C,SAHI,CAAN;AAID;AACF,KApPG,CAsPJ;;AAtPI;AAAA;AAAA;AAAA;AAAA;;AAuPJ,MAAG,CAACwC,UAAU,CAACC,KAAf,EAAsB;AACpB,QAAG,WAAWzC,SAAd,EAAyB;AACvB,UAAG,CAACA,SAAS,CAAC,OAAD,CAAb,EAAwB;AACtB;AACA,eAAOuC,GAAP;AACD,OAHD,MAGO;AACL,eAAOrD,WAAW,CAACE,YAAY,CAAC6D,IAAD,EAAOjD,SAAS,CAAC,OAAD,CAAhB,CAAb,EAAyCuC,GAAzC,CAAlB;AACD;AACF,KAPD,MAOO;AACL,aAAOrD,WAAW,CAAC+D,IAAD,EAAOV,GAAP,CAAlB;AACD;AACF,GAlQG,CAoQJ;;;AACA,SAAOA,GAAP;AACD,CA7QD;AA+QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3C,GAAG,CAAC4B,YAAJ,GAAmB,iBAAiD;AAAA,MAA/CxB,SAA+C,SAA/CA,SAA+C;AAAA,MAApCC,cAAoC,SAApCA,cAAoC;AAAA,MAApBwB,KAAoB,SAApBA,KAAoB;AAAA,MAAbtB,OAAa,SAAbA,OAAa;;AAClE;AACA,MAAGnC,QAAQ,CAACyD,KAAD,CAAX,EAAoB;AAClB;AACA,QAAMW,KAAI,GAAG1D,gBAAgB,CAACsB,SAAD,EAAYC,cAAZ,EAA4B,OAA5B,CAA7B;;AACA,QAAM8G,QAAQ,GAAGrI,gBAAgB,CAACsB,SAAD,EAAYC,cAAZ,EAA4B,WAA5B,CAAjC;;AACA,QAAM+G,SAAS,GAAGtI,gBAAgB,CAACsB,SAAD,EAAYC,cAAZ,EAA4B,YAA5B,CAAlC;;AACA,QAAMc,SAAS,GACbrC,gBAAgB,CAACsB,SAAD,EAAYC,cAAZ,EAA4B,YAA5B,CAAhB,IAA6D,EAD/D,CALkB,CAQlB;;AACA,QAAMgH,aAAa,GAAG,YAAYxF,KAAZ,IAAqB,CAACV,SAAS,CAACW,QAAV,CAAmB,QAAnB,CAA5C,CATkB,CAWlB;;AACA,QAAG,CAACuF,aAAD,IAAkB7E,KAAI,KAAK,OAA9B,EAAuC;AACrC;AACA,UAAGX,KAAK,CAAC,OAAD,CAAL,KAAmBW,KAAtB,EAA4B;AAC1B,eAAOX,KAAK,CAAC,QAAD,CAAZ;AACD;;AACD,UAAG,eAAeA,KAAf,IAAwBA,KAAK,CAAC,WAAD,CAAL,KAAuBsF,QAA/C,IACA,gBAAgBtF,KADhB,IACyBA,KAAK,CAAC,YAAD,CAAL,KAAwBuF,SADpD,EAC+D;AAC7D,eAAOvF,KAAK,CAAC,QAAD,CAAZ;AACD;;AACD,UAAG,eAAeA,KAAf,IAAwBA,KAAK,CAAC,WAAD,CAAL,KAAuBsF,QAAlD,EAA4D;AAC1D,eAAOtF,KAAK,CAAC,QAAD,CAAZ;AACD;;AACD,UAAG,gBAAgBA,KAAhB,IAAyBA,KAAK,CAAC,YAAD,CAAL,KAAwBuF,SAApD,EAA+D;AAC7D,eAAOvF,KAAK,CAAC,QAAD,CAAZ;AACD;AACF,KA3BiB,CA6BlB;AACA;AACA;AACA;;;AACA,QAAMyF,QAAQ,GAAGvE,MAAM,CAACD,IAAP,CAAYjB,KAAZ,EAAmBjB,MAApC;AACA,QAAM2G,cAAc,GAAID,QAAQ,KAAK,CAAb,IACrBA,QAAQ,KAAK,CAAb,IAAkB,YAAYzF,KAA9B,IAAuC,CAACwF,aAD3C;AAEA,QAAMG,kBAAkB,IAAI,eAAepH,SAAnB,CAAxB;;AACA,QAAMqH,aAAa,GAAG3J,SAAS,CAAC+D,KAAK,CAAC,QAAD,CAAN,CAA/B;;AACA,QAAM6F,cAAc,GAAItH,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBtD,cAAvB,KACtBD,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBvD,cAAvB,EAAuC,WAAvC,MAAwD,IAD1D;;AAEA,QAAGkH,cAAc,IACf/E,KAAI,KAAK,OADR,KAEA,CAACgF,kBAAD,IAAuB,CAACC,aAAxB,IAAyCC,cAFzC,CAAH,EAE6D;AAC3D,aAAO7F,KAAK,CAAC,QAAD,CAAZ;AACD;;AAED,QAAMnB,IAAI,GAAG,EAAb,CA9CkB,CAgDlB;;AACA,QAAG2G,aAAH,EAAkB;AAChB3G,MAAAA,IAAI,CAACV,GAAG,CAAC0C,UAAJ,CAAe;AAClBtC,QAAAA,SAAS,EAATA,SADkB;AAElBuC,QAAAA,GAAG,EAAE,QAFa;AAGlBC,QAAAA,UAAU,EAAE;AAACC,UAAAA,KAAK,EAAE;AAAR;AAHM,OAAf,CAAD,CAAJ,GAIMhB,KAAK,CAAC,QAAD,CAJX;AAKD;;AAED,QAAG,WAAWA,KAAd,EAAqB;AACnB;AACAnB,MAAAA,IAAI,CAACV,GAAG,CAAC0C,UAAJ,CAAe;AAClBtC,QAAAA,SAAS,EAATA,SADkB;AAElBuC,QAAAA,GAAG,EAAE,OAFa;AAGlBC,QAAAA,UAAU,EAAE;AAACC,UAAAA,KAAK,EAAE;AAAR;AAHM,OAAf,CAAD,CAAJ,GAIM7C,GAAG,CAAC0C,UAAJ,CACJ;AAACtC,QAAAA,SAAS,EAATA,SAAD;AAAYuC,QAAAA,GAAG,EAAEd,KAAK,CAAC,OAAD,CAAtB;AAAiCe,QAAAA,UAAU,EAAE;AAACC,UAAAA,KAAK,EAAE;AAAR;AAA7C,OADI,CAJN;AAMD,KARD,MAQO,IAAG,eAAehB,KAAlB,EAAyB;AAC9B;AACAnB,MAAAA,IAAI,CAACV,GAAG,CAAC0C,UAAJ,CAAe;AAClBtC,QAAAA,SAAS,EAATA,SADkB;AAElBuC,QAAAA,GAAG,EAAE,WAFa;AAGlBC,QAAAA,UAAU,EAAE;AAACC,UAAAA,KAAK,EAAE;AAAR;AAHM,OAAf,CAAD,CAAJ,GAIMhB,KAAK,CAAC,WAAD,CAJX;AAKD;;AAED,QAAG,gBAAgBA,KAAnB,EAA0B;AACxB;AACAnB,MAAAA,IAAI,CAACV,GAAG,CAAC0C,UAAJ,CAAe;AAClBtC,QAAAA,SAAS,EAATA,SADkB;AAElBuC,QAAAA,GAAG,EAAE,YAFa;AAGlBC,QAAAA,UAAU,EAAE;AAACC,UAAAA,KAAK,EAAE;AAAR;AAHM,OAAf,CAAD,CAAJ,GAIMhB,KAAK,CAAC,YAAD,CAJX;AAKD,KAjFiB,CAmFlB;;;AACAnB,IAAAA,IAAI,CAACV,GAAG,CAAC0C,UAAJ,CAAe;AAClBtC,MAAAA,SAAS,EAATA,SADkB;AAElBuC,MAAAA,GAAG,EAAE,QAFa;AAGlBC,MAAAA,UAAU,EAAE;AAACC,QAAAA,KAAK,EAAE;AAAR;AAHM,KAAf,CAAD,CAAJ,GAIMhB,KAAK,CAAC,QAAD,CAJX;AAMA,WAAOnB,IAAP;AACD,GA7FiE,CA+FlE;;;AACA,MAAMsC,gBAAgB,GAAGpE,UAAU,CAACwB,SAAD,EAAYC,cAAZ,EAA4B;AAACwC,IAAAA,KAAK,EAAE;AAAR,GAA5B,EACjCtC,OADiC,CAAnC;;AAEA,MAAMiC,IAAI,GAAG1D,gBAAgB,CAACsB,SAAD,EAAYC,cAAZ,EAA4B,OAA5B,CAA7B;;AACA,MAAMQ,SAAS,GAAGb,GAAG,CAAC0C,UAAJ,CAAe;AAC/BtC,IAAAA,SAAS,EAATA,SAD+B;AAE/BuC,IAAAA,GAAG,EAAEd,KAAK,CAAC,KAAD,CAFqB;AAG/Be,IAAAA,UAAU,EAAE;AAACC,MAAAA,KAAK,EAAEL,IAAI,KAAK;AAAjB,KAHmB;AAI/Ba,IAAAA,IAAI,EAAE9C,OAAO,CAAC8C;AAJiB,GAAf,CAAlB,CAnGkE,CAyGlE;;AACA,MAAGb,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,QAA3B,IAAuCQ,gBAAgB,KAAK,QAA/D,EAAyE;AACvE,WAAOnC,SAAP;AACD;;AAED,6BACGb,GAAG,CAAC0C,UAAJ,CAAe;AACdtC,IAAAA,SAAS,EAATA,SADc;AAEduC,IAAAA,GAAG,EAAE,KAFS;AAGdC,IAAAA,UAAU,EAAE;AAACC,MAAAA,KAAK,EAAE;AAAR;AAHE,GAAf,CADH,EAKOhC,SALP;AAOD,CArHD;AAuHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoF,WAAT,CACE7F,SADF,EACauC,GADb,EACkBd,KADlB,EACyBuD,UADzB,EACqCC,cADrC,EACqDC,mBADrD,EAC0E;AACxE,MAAGA,mBAAmB,KAAK,IAA3B,EAAiC;AAC/BA,IAAAA,mBAAmB,GAAG,OAAtB;AACD,GAHuE,CAKxE;;;AACA,MAAMqC,KAAK,GAAG,EAAd,CANwE,CAQxE;;AACA,MAAG,CAACrC,mBAAmB,KAAK,KAAxB,IAAiCA,mBAAmB,KAAK,UAA1D,KACD1H,SAAS,CAACiE,KAAD,CADR,IACmB,SAASA,KAD/B,EACsC;AACpC;AACA,QAAGyD,mBAAmB,KAAK,UAA3B,EAAuC;AACrCqC,MAAAA,KAAK,CAAC1G,IAAN,CAAW,UAAX;AACD,KAJmC,CAKpC;;;AACA,QAAM+E,IAAI,GAAGhG,GAAG,CAAC0C,UAAJ,CACX;AAACtC,MAAAA,SAAS,EAATA,SAAD;AAAYuC,MAAAA,GAAG,EAAEd,KAAK,CAAC,KAAD,CAAtB;AAA+Be,MAAAA,UAAU,EAAE;AAACC,QAAAA,KAAK,EAAE;AAAR;AAA3C,KADW,CAAb;;AAEA,QAAGzC,SAAS,CAACsD,QAAV,CAAmBC,GAAnB,CAAuBqC,IAAvB,KACD5F,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBoC,IAAvB,CADC,IAED5F,SAAS,CAACsD,QAAV,CAAmBE,GAAnB,CAAuBoC,IAAvB,EAA6B,KAA7B,MAAwCnE,KAAK,CAAC,KAAD,CAF/C,EAEwD;AACtD;AACA8F,MAAAA,KAAK,CAAC1G,IAAN,CAAW2G,KAAX,CAAiBD,KAAjB,EAAwB,CAAC,QAAD,EAAW,KAAX,CAAxB;AACD,KALD,MAKO;AACL;AACAA,MAAAA,KAAK,CAAC1G,IAAN,CAAW2G,KAAX,CAAiBD,KAAjB,EAAwB,CAAC,KAAD,EAAQ,QAAR,CAAxB;AACD;AACF,GAlBD,MAkBO;AACLA,IAAAA,KAAK,CAAC1G,IAAN,CAAWqE,mBAAX,EADK,CAGL;;AACA,QAAMuC,OAAO,GAAGF,KAAK,CAACG,IAAN,CAAW,UAAAC,EAAE;AAAA,aAAIA,EAAE,CAACjG,QAAH,CAAY,GAAZ,CAAJ;AAAA,KAAb,CAAhB;;AACA,QAAG+F,OAAH,EAAY;AACV;AACAF,MAAAA,KAAK,CAAC1G,IAAN,CAAW4G,OAAO,CAACG,OAAR,CAAgB,SAAhB,EAA2B,GAA3B,CAAX;AACD;AACF;;AACDL,EAAAA,KAAK,CAAC1G,IAAN,CAAW,OAAX;AAEA,MAAMgH,YAAY,GAAG7H,SAAS,CAAC8H,OAAV,CAAkBvF,GAAlB,CAArB;;AAvCwE,8CAwCjDyC,UAxCiD;AAAA;;AAAA;AAwCxE,2DAAmC;AAAA,UAAzBjE,SAAyB;;AACjC;AACA,UAAG,EAAEA,SAAS,IAAI8G,YAAf,CAAH,EAAiC;AAC/B;AACD;;AAED,UAAME,sBAAsB,GAAGF,YAAY,CAAC9G,SAAD,CAAZ,CAAwBkE,cAAxB,CAA/B;;AANiC,kDAOfsC,KAPe;AAAA;;AAAA;AAOjC,+DAAyB;AAAA,cAAfS,IAAe;;AACvB;AACA,cAAG,EAAEA,IAAI,IAAID,sBAAV,CAAH,EAAsC;AACpC;AACD,WAJsB,CAMvB;;;AACA,iBAAOA,sBAAsB,CAACC,IAAD,CAA7B;AACD;AAfgC;AAAA;AAAA;AAAA;AAAA;AAgBlC;AAxDuE;AAAA;AAAA;AAAA;AAAA;;AA0DxE,SAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASlE,kBAAT,CAA4B9D,SAA5B,EAAuC4D,YAAvC,EAAqDzD,OAArD,EAA8D;AAC5D,MAAG3B,UAAU,CAACwB,SAAD,EAAY4D,YAAZ,EAA0B;AAACnB,IAAAA,KAAK,EAAE;AAAR,GAA1B,EAAyCtC,OAAzC,CAAV,KAAgE,OAAnE,EAA4E;AAC1E,UAAM,IAAI/C,WAAJ,CACJ,qEACA,qBAFI,EAGJ,oBAHI,EAGkB;AAACyJ,MAAAA,IAAI,EAAE;AAAP,KAHlB,CAAN;AAID;AACF","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"]},"metadata":{},"sourceType":"script"}