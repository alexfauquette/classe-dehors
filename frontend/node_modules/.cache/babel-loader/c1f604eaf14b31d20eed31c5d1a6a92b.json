{"ast":null,"code":"/*\n * Copyright (c) 2016-2020 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _objectSpread = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/alexandre/dev/classe-dehors/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar IdentifierIssuer = require('./IdentifierIssuer');\n\nvar MessageDigest = require('./MessageDigest');\n\nvar Permuter = require('./Permuter');\n\nvar NQuads = require('./NQuads');\n\nmodule.exports = /*#__PURE__*/function () {\n  function URDNA2015Sync() {\n    _classCallCheck(this, URDNA2015Sync);\n\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    this.hashAlgorithm = 'sha256';\n    this.quads = null;\n  } // 4.4) Normalization Algorithm\n\n\n  _createClass(URDNA2015Sync, [{\n    key: \"main\",\n    value: function main(dataset) {\n      this.quads = dataset; // 1) Create the normalization state.\n      // 2) For every quad in input dataset:\n\n      var _iterator = _createForOfIteratorHelper(dataset),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var quad = _step.value;\n\n          // 2.1) For each blank node that occurs in the quad, add a reference\n          // to the quad using the blank node identifier in the blank node to\n          // quads map, creating a new entry if necessary.\n          this._addBlankNodeQuadInfo({\n            quad: quad,\n            component: quad.subject\n          });\n\n          this._addBlankNodeQuadInfo({\n            quad: quad,\n            component: quad.object\n          });\n\n          this._addBlankNodeQuadInfo({\n            quad: quad,\n            component: quad.graph\n          });\n        } // 3) Create a list of non-normalized blank node identifiers\n        // non-normalized identifiers and populate it using the keys from the\n        // blank node to quads map.\n        // Note: We use a map here and it was generated during step 2.\n        // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n        // is permitted because there was a typo in the hash first degree quads\n        // algorithm in the URDNA2015 spec that was implemented widely making it\n        // such that it could not be fixed; the result was that the loop only\n        // needs to be run once and the first degree quad hashes will never change.\n        // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n        // for all non-normalized blank nodes.\n        // 5.3) For each blank node identifier identifier in non-normalized\n        // identifiers:\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var hashToBlankNodes = new Map();\n\n      var nonNormalized = _toConsumableArray(this.blankNodeInfo.keys());\n\n      var _iterator2 = _createForOfIteratorHelper(nonNormalized),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _id2 = _step2.value;\n\n          // steps 5.3.1 and 5.3.2:\n          this._hashAndTrackBlankNode({\n            id: _id2,\n            hashToBlankNodes: hashToBlankNodes\n          });\n        } // 5.4) For each hash to identifier list mapping in hash to blank\n        // nodes map, lexicographically-sorted by hash:\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var hashes = _toConsumableArray(hashToBlankNodes.keys()).sort(); // optimize away second sort, gather non-unique hashes in order as we go\n\n\n      var nonUnique = [];\n\n      var _iterator3 = _createForOfIteratorHelper(hashes),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var hash = _step3.value;\n\n          // 5.4.1) If the length of identifier list is greater than 1,\n          // continue to the next mapping.\n          var _idList = hashToBlankNodes.get(hash);\n\n          if (_idList.length > 1) {\n            nonUnique.push(_idList);\n            continue;\n          } // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n          // issuer and the single blank node identifier in identifier\n          // list, identifier, to issue a canonical replacement identifier\n          // for identifier.\n\n\n          var _id3 = _idList[0];\n          this.canonicalIssuer.getId(_id3); // Note: These steps are skipped, optimized away since the loop\n          // only needs to be run once.\n          // 5.4.3) Remove identifier from non-normalized identifiers.\n          // 5.4.4) Remove hash from the hash to blank nodes map.\n          // 5.4.5) Set simple to true.\n        } // 6) For each hash to identifier list mapping in hash to blank nodes map,\n        // lexicographically-sorted by hash:\n        // Note: sort optimized away, use `nonUnique`.\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      for (var _i = 0, _nonUnique = nonUnique; _i < _nonUnique.length; _i++) {\n        var idList = _nonUnique[_i];\n        // 6.1) Create hash path list where each item will be a result of\n        // running the Hash N-Degree Quads algorithm.\n        var hashPathList = []; // 6.2) For each blank node identifier identifier in identifier list:\n\n        var _iterator4 = _createForOfIteratorHelper(idList),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _id = _step4.value;\n\n            // 6.2.1) If a canonical identifier has already been issued for\n            // identifier, continue to the next identifier.\n            if (this.canonicalIssuer.hasId(_id)) {\n              continue;\n            } // 6.2.2) Create temporary issuer, an identifier issuer\n            // initialized with the prefix _:b.\n\n\n            var issuer = new IdentifierIssuer('_:b'); // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n            // issuer and identifier, to issue a new temporary blank node\n            // identifier for identifier.\n\n            issuer.getId(_id); // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n            // temporary issuer, and append the result to the hash path list.\n\n            var _result = this.hashNDegreeQuads(_id, issuer);\n\n            hashPathList.push(_result);\n          } // 6.3) For each result in the hash path list,\n          // lexicographically-sorted by the hash in result:\n\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        hashPathList.sort(_stringHashCompare);\n\n        for (var _i2 = 0, _hashPathList = hashPathList; _i2 < _hashPathList.length; _i2++) {\n          var result = _hashPathList[_i2];\n          // 6.3.1) For each blank node identifier, existing identifier,\n          // that was issued a temporary identifier by identifier issuer\n          // in result, issue a canonical identifier, in the same order,\n          // using the Issue Identifier algorithm, passing canonical\n          // issuer and existing identifier.\n          var oldIds = result.issuer.getOldIds();\n\n          var _iterator5 = _createForOfIteratorHelper(oldIds),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var id = _step5.value;\n              this.canonicalIssuer.getId(id);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }\n      /* Note: At this point all blank nodes in the set of RDF quads have been\n      assigned canonical identifiers, which have been stored in the canonical\n      issuer. Here each quad is updated by assigning each of its blank nodes\n      its new identifier. */\n      // 7) For each quad, quad, in input dataset:\n\n\n      var normalized = [];\n\n      var _iterator6 = _createForOfIteratorHelper(this.quads),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _quad = _step6.value;\n\n          // 7.1) Create a copy, quad copy, of quad and replace any existing\n          // blank node identifiers using the canonical identifiers\n          // previously issued by canonical issuer.\n          // Note: We optimize with shallow copies here.\n          var q = _objectSpread({}, _quad);\n\n          q.subject = this._useCanonicalId({\n            component: q.subject\n          });\n          q.object = this._useCanonicalId({\n            component: q.object\n          });\n          q.graph = this._useCanonicalId({\n            component: q.graph\n          }); // 7.2) Add quad copy to the normalized dataset.\n\n          normalized.push(NQuads.serializeQuad(q));\n        } // sort normalized output\n\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      normalized.sort(); // 8) Return the normalized dataset.\n\n      return normalized.join('');\n    } // 4.6) Hash First Degree Quads\n\n  }, {\n    key: \"hashFirstDegreeQuads\",\n    value: function hashFirstDegreeQuads(id) {\n      // 1) Initialize nquads to an empty list. It will be used to store quads in\n      // N-Quads format.\n      var nquads = []; // 2) Get the list of quads `quads` associated with the reference blank node\n      // identifier in the blank node to quads map.\n\n      var info = this.blankNodeInfo.get(id);\n      var quads = info.quads; // 3) For each quad `quad` in `quads`:\n\n      var _iterator7 = _createForOfIteratorHelper(quads),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var quad = _step7.value;\n          // 3.1) Serialize the quad in N-Quads format with the following special\n          // rule:\n          // 3.1.1) If any component in quad is an blank node, then serialize it\n          // using a special identifier as follows:\n          var copy = {\n            subject: null,\n            predicate: quad.predicate,\n            object: null,\n            graph: null\n          }; // 3.1.2) If the blank node's existing blank node identifier matches\n          // the reference blank node identifier then use the blank node\n          // identifier _:a, otherwise, use the blank node identifier _:z.\n\n          copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, 'subject');\n          copy.object = this.modifyFirstDegreeComponent(id, quad.object, 'object');\n          copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, 'graph');\n          nquads.push(NQuads.serializeQuad(copy));\n        } // 4) Sort nquads in lexicographical order.\n\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      nquads.sort(); // 5) Return the hash that results from passing the sorted, joined nquads\n      // through the hash algorithm.\n\n      var md = new MessageDigest(this.hashAlgorithm);\n\n      for (var _i3 = 0, _nquads = nquads; _i3 < _nquads.length; _i3++) {\n        var nquad = _nquads[_i3];\n        md.update(nquad);\n      }\n\n      info.hash = md.digest();\n      return info.hash;\n    } // 4.7) Hash Related Blank Node\n\n  }, {\n    key: \"hashRelatedBlankNode\",\n    value: function hashRelatedBlankNode(related, quad, issuer, position) {\n      // 1) Set the identifier to use for related, preferring first the canonical\n      // identifier for related if issued, second the identifier issued by issuer\n      // if issued, and last, if necessary, the result of the Hash First Degree\n      // Quads algorithm, passing related.\n      var id;\n\n      if (this.canonicalIssuer.hasId(related)) {\n        id = this.canonicalIssuer.getId(related);\n      } else if (issuer.hasId(related)) {\n        id = issuer.getId(related);\n      } else {\n        id = this.blankNodeInfo.get(related).hash;\n      } // 2) Initialize a string input to the value of position.\n      // Note: We use a hash object instead.\n\n\n      var md = new MessageDigest(this.hashAlgorithm);\n      md.update(position); // 3) If position is not g, append <, the value of the predicate in quad,\n      // and > to input.\n\n      if (position !== 'g') {\n        md.update(this.getRelatedPredicate(quad));\n      } // 4) Append identifier to input.\n\n\n      md.update(id); // 5) Return the hash that results from passing input through the hash\n      // algorithm.\n\n      return md.digest();\n    } // 4.8) Hash N-Degree Quads\n\n  }, {\n    key: \"hashNDegreeQuads\",\n    value: function hashNDegreeQuads(id, issuer) {\n      // 1) Create a hash to related blank nodes map for storing hashes that\n      // identify related blank nodes.\n      // Note: 2) and 3) handled within `createHashToRelated`\n      var md = new MessageDigest(this.hashAlgorithm);\n      var hashToRelated = this.createHashToRelated(id, issuer); // 4) Create an empty string, data to hash.\n      // Note: We created a hash object `md` above instead.\n      // 5) For each related hash to blank node list mapping in hash to related\n      // blank nodes map, sorted lexicographically by related hash:\n\n      var hashes = _toConsumableArray(hashToRelated.keys()).sort();\n\n      var _iterator8 = _createForOfIteratorHelper(hashes),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var hash = _step8.value;\n          // 5.1) Append the related hash to the data to hash.\n          md.update(hash); // 5.2) Create a string chosen path.\n\n          var chosenPath = ''; // 5.3) Create an unset chosen issuer variable.\n\n          var chosenIssuer = void 0; // 5.4) For each permutation of blank node list:\n\n          var permuter = new Permuter(hashToRelated.get(hash));\n\n          while (permuter.hasNext()) {\n            var permutation = permuter.next(); // 5.4.1) Create a copy of issuer, issuer copy.\n\n            var issuerCopy = issuer.clone(); // 5.4.2) Create a string path.\n\n            var path = ''; // 5.4.3) Create a recursion list, to store blank node identifiers\n            // that must be recursively processed by this algorithm.\n\n            var recursionList = []; // 5.4.4) For each related in permutation:\n\n            var nextPermutation = false;\n\n            var _iterator9 = _createForOfIteratorHelper(permutation),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _related = _step9.value;\n\n                // 5.4.4.1) If a canonical identifier has been issued for\n                // related, append it to path.\n                if (this.canonicalIssuer.hasId(_related)) {\n                  path += this.canonicalIssuer.getId(_related);\n                } else {\n                  // 5.4.4.2) Otherwise:\n                  // 5.4.4.2.1) If issuer copy has not issued an identifier for\n                  // related, append related to recursion list.\n                  if (!issuerCopy.hasId(_related)) {\n                    recursionList.push(_related);\n                  } // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n                  // issuer copy and related and append the result to path.\n\n\n                  path += issuerCopy.getId(_related);\n                } // 5.4.4.3) If chosen path is not empty and the length of path\n                // is greater than or equal to the length of chosen path and\n                // path is lexicographically greater than chosen path, then\n                // skip to the next permutation.\n                // Note: Comparing path length to chosen path length can be optimized\n                // away; only compare lexicographically.\n\n\n                if (chosenPath.length !== 0 && path > chosenPath) {\n                  nextPermutation = true;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            if (nextPermutation) {\n              continue;\n            } // 5.4.5) For each related in recursion list:\n\n\n            for (var _i4 = 0, _recursionList = recursionList; _i4 < _recursionList.length; _i4++) {\n              var related = _recursionList[_i4];\n              // 5.4.5.1) Set result to the result of recursively executing\n              // the Hash N-Degree Quads algorithm, passing related for\n              // identifier and issuer copy for path identifier issuer.\n              var result = this.hashNDegreeQuads(related, issuerCopy); // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n              // copy and related and append the result to path.\n\n              path += issuerCopy.getId(related); // 5.4.5.3) Append <, the hash in result, and > to path.\n\n              path += \"<\".concat(result.hash, \">\"); // 5.4.5.4) Set issuer copy to the identifier issuer in\n              // result.\n\n              issuerCopy = result.issuer; // 5.4.5.5) If chosen path is not empty and the length of path\n              // is greater than or equal to the length of chosen path and\n              // path is lexicographically greater than chosen path, then\n              // skip to the next permutation.\n              // Note: Comparing path length to chosen path length can be optimized\n              // away; only compare lexicographically.\n\n              if (chosenPath.length !== 0 && path > chosenPath) {\n                nextPermutation = true;\n                break;\n              }\n            }\n\n            if (nextPermutation) {\n              continue;\n            } // 5.4.6) If chosen path is empty or path is lexicographically\n            // less than chosen path, set chosen path to path and chosen\n            // issuer to issuer copy.\n\n\n            if (chosenPath.length === 0 || path < chosenPath) {\n              chosenPath = path;\n              chosenIssuer = issuerCopy;\n            }\n          } // 5.5) Append chosen path to data to hash.\n\n\n          md.update(chosenPath); // 5.6) Replace issuer, by reference, with chosen issuer.\n\n          issuer = chosenIssuer;\n        } // 6) Return issuer and the hash that results from passing data to hash\n        // through the hash algorithm.\n\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return {\n        hash: md.digest(),\n        issuer: issuer\n      };\n    } // helper for modifying component during Hash First Degree Quads\n\n  }, {\n    key: \"modifyFirstDegreeComponent\",\n    value: function modifyFirstDegreeComponent(id, component) {\n      if (component.termType !== 'BlankNode') {\n        return component;\n      }\n      /* Note: A mistake in the URDNA2015 spec that made its way into\n      implementations (and therefore must stay to avoid interop breakage)\n      resulted in an assigned canonical ID, if available for\n      `component.value`, not being used in place of `_:a`/`_:z`, so\n      we don't use it here. */\n\n\n      return {\n        termType: 'BlankNode',\n        value: component.value === id ? '_:a' : '_:z'\n      };\n    } // helper for getting a related predicate\n\n  }, {\n    key: \"getRelatedPredicate\",\n    value: function getRelatedPredicate(quad) {\n      return \"<\".concat(quad.predicate.value, \">\");\n    } // helper for creating hash to related blank nodes map\n\n  }, {\n    key: \"createHashToRelated\",\n    value: function createHashToRelated(id, issuer) {\n      // 1) Create a hash to related blank nodes map for storing hashes that\n      // identify related blank nodes.\n      var hashToRelated = new Map(); // 2) Get a reference, quads, to the list of quads in the blank node to\n      // quads map for the key identifier.\n\n      var quads = this.blankNodeInfo.get(id).quads; // 3) For each quad in quads:\n\n      var _iterator10 = _createForOfIteratorHelper(quads),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var quad = _step10.value;\n\n          // 3.1) For each component in quad, if component is the subject, object,\n          // or graph name and it is a blank node that is not identified by\n          // identifier:\n          // steps 3.1.1 and 3.1.2 occur in helpers:\n          this._addRelatedBlankNodeHash({\n            quad: quad,\n            component: quad.subject,\n            position: 's',\n            id: id,\n            issuer: issuer,\n            hashToRelated: hashToRelated\n          });\n\n          this._addRelatedBlankNodeHash({\n            quad: quad,\n            component: quad.object,\n            position: 'o',\n            id: id,\n            issuer: issuer,\n            hashToRelated: hashToRelated\n          });\n\n          this._addRelatedBlankNodeHash({\n            quad: quad,\n            component: quad.graph,\n            position: 'g',\n            id: id,\n            issuer: issuer,\n            hashToRelated: hashToRelated\n          });\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return hashToRelated;\n    }\n  }, {\n    key: \"_hashAndTrackBlankNode\",\n    value: function _hashAndTrackBlankNode(_ref) {\n      var id = _ref.id,\n          hashToBlankNodes = _ref.hashToBlankNodes;\n      // 5.3.1) Create a hash, hash, according to the Hash First Degree\n      // Quads algorithm.\n      var hash = this.hashFirstDegreeQuads(id); // 5.3.2) Add hash and identifier to hash to blank nodes map,\n      // creating a new entry if necessary.\n\n      var idList = hashToBlankNodes.get(hash);\n\n      if (!idList) {\n        hashToBlankNodes.set(hash, [id]);\n      } else {\n        idList.push(id);\n      }\n    }\n  }, {\n    key: \"_addBlankNodeQuadInfo\",\n    value: function _addBlankNodeQuadInfo(_ref2) {\n      var quad = _ref2.quad,\n          component = _ref2.component;\n\n      if (component.termType !== 'BlankNode') {\n        return;\n      }\n\n      var id = component.value;\n      var info = this.blankNodeInfo.get(id);\n\n      if (info) {\n        info.quads.add(quad);\n      } else {\n        this.blankNodeInfo.set(id, {\n          quads: new Set([quad]),\n          hash: null\n        });\n      }\n    }\n  }, {\n    key: \"_addRelatedBlankNodeHash\",\n    value: function _addRelatedBlankNodeHash(_ref3) {\n      var quad = _ref3.quad,\n          component = _ref3.component,\n          position = _ref3.position,\n          id = _ref3.id,\n          issuer = _ref3.issuer,\n          hashToRelated = _ref3.hashToRelated;\n\n      if (!(component.termType === 'BlankNode' && component.value !== id)) {\n        return;\n      } // 3.1.1) Set hash to the result of the Hash Related Blank Node\n      // algorithm, passing the blank node identifier for component as\n      // related, quad, path identifier issuer as issuer, and position as\n      // either s, o, or g based on whether component is a subject, object,\n      // graph name, respectively.\n\n\n      var related = component.value;\n      var hash = this.hashRelatedBlankNode(related, quad, issuer, position); // 3.1.2) Add a mapping of hash to the blank node identifier for\n      // component to hash to related blank nodes map, adding an entry as\n      // necessary.\n\n      var entries = hashToRelated.get(hash);\n\n      if (entries) {\n        entries.push(related);\n      } else {\n        hashToRelated.set(hash, [related]);\n      }\n    }\n  }, {\n    key: \"_useCanonicalId\",\n    value: function _useCanonicalId(_ref4) {\n      var component = _ref4.component;\n\n      if (component.termType === 'BlankNode' && !component.value.startsWith(this.canonicalIssuer.prefix)) {\n        return {\n          termType: 'BlankNode',\n          value: this.canonicalIssuer.getId(component.value)\n        };\n      }\n\n      return component;\n    }\n  }]);\n\n  return URDNA2015Sync;\n}();\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}","map":{"version":3,"sources":["/home/alexandre/dev/classe-dehors/frontend/node_modules/rdf-canonize/lib/URDNA2015Sync.js"],"names":["IdentifierIssuer","require","MessageDigest","Permuter","NQuads","module","exports","name","blankNodeInfo","Map","canonicalIssuer","hashAlgorithm","quads","dataset","quad","_addBlankNodeQuadInfo","component","subject","object","graph","hashToBlankNodes","nonNormalized","keys","id","_hashAndTrackBlankNode","hashes","sort","nonUnique","hash","idList","get","length","push","getId","hashPathList","hasId","issuer","result","hashNDegreeQuads","_stringHashCompare","oldIds","getOldIds","normalized","q","_useCanonicalId","serializeQuad","join","nquads","info","copy","predicate","modifyFirstDegreeComponent","md","nquad","update","digest","related","position","getRelatedPredicate","hashToRelated","createHashToRelated","chosenPath","chosenIssuer","permuter","hasNext","permutation","next","issuerCopy","clone","path","recursionList","nextPermutation","termType","value","_addRelatedBlankNodeHash","hashFirstDegreeQuads","set","add","Set","hashRelatedBlankNode","entries","startsWith","prefix","a","b"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-2020 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst IdentifierIssuer = require('./IdentifierIssuer');\nconst MessageDigest = require('./MessageDigest');\nconst Permuter = require('./Permuter');\nconst NQuads = require('./NQuads');\n\nmodule.exports = class URDNA2015Sync {\n  constructor() {\n    this.name = 'URDNA2015';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('_:c14n');\n    this.hashAlgorithm = 'sha256';\n    this.quads = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  main(dataset) {\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the URDNA2015 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    for(const id of nonNormalized) {\n      // steps 5.3.1 and 5.3.2:\n      this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('_:b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize with shallow copies here.\n      const q = {...quad};\n      q.subject = this._useCanonicalId({component: q.subject});\n      q.object = this._useCanonicalId({component: q.object});\n      q.graph = this._useCanonicalId({component: q.graph});\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(NQuads.serializeQuad(q));\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      const copy = {\n        subject: null, predicate: quad.predicate, object: null, graph: null\n      };\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      copy.subject = this.modifyFirstDegreeComponent(\n        id, quad.subject, 'subject');\n      copy.object = this.modifyFirstDegreeComponent(\n        id, quad.object, 'object');\n      copy.graph = this.modifyFirstDegreeComponent(\n        id, quad.graph, 'graph');\n      nquads.push(NQuads.serializeQuad(copy));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = new MessageDigest(this.hashAlgorithm);\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 2) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = new MessageDigest(this.hashAlgorithm);\n    md.update(position);\n\n    // 3) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  hashNDegreeQuads(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = new MessageDigest(this.hashAlgorithm);\n    const hashToRelated = this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the URDNA2015 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? '_:a' : '_:z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    for(const quad of quads) {\n      // 3.1) For each component in quad, if component is the subject, object,\n      // or graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.subject, position: 's',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.object, position: 'o',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.graph, position: 'g',\n        id, issuer, hashToRelated\n      });\n    }\n\n    return hashToRelated;\n  }\n\n  _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = this.hashRelatedBlankNode(related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  _useCanonicalId({component}) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n"]},"metadata":{},"sourceType":"script"}